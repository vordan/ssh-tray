This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: src/lib/vendor/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
archive/
  ssh_tray.old.py
config/
  ssh-bookmarks.sample.txt
  ssh-tray-config.sample.txt
  ssh-tray-uninstall.desktop
scripts/
  git_commit.sh
  git_init.sh
  github_cli_install.sh
  make_ssh_tray_project.sh
  uninstall.sh
src/
  ssh_tray/
    __init__.py
    configuration.py
    constants.py
    dialogs.py
    editor.py
    main.py
    sync.py
    system.py
    widgets.py
  sync_service/
    sync_service.js
  ssh_tray.py
test/
  .user_id
  service-test.sh
  sync-module-test.sh
  test-bookmarks.txt
web/
  index.html
INSTALL.md
install.sh
LICENSE.md
MAKE.md
README.md
repomix.config.json
ssh-tray-start.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/ssh_tray/sync.py">
"""
===============================================================================
ssh_tray.sync.py - Configuration sync functionality for SSH Bookmark Manager
Author: Vanco Ordanoski
MIT License

Handles syncing SSH bookmarks across multiple computers using a central server.
===============================================================================
"""

# Suppress urllib3/chardet version warnings from requests
import warnings
warnings.filterwarnings('ignore')  # Suppress all warnings

import os
import requests
from .configuration import BOOKMARKS_FILE, CONFIG_FILE
from .system import show_notification

SYNC_CONFIG_FILE = os.path.expanduser('~/.ssh-tray-sync')
USER_ID_FILE = '/opt/ssh-tray/.user_id'

def get_sync_config():
	"""Read sync configuration from file.

	Returns:
		dict: Sync configuration with server, port, user_id, enabled status
	"""
	config = {
		'enabled': False,
		'server': 'localhost',
		'port': 9182,
		'user_id': None
	}

	# Read main config for server settings
	if os.path.exists(CONFIG_FILE):
		try:
			with open(CONFIG_FILE, 'r') as f:
				for line in f:
					line = line.strip()
					if line.startswith('sync_server='):
						config['server'] = line.split('=', 1)[1].strip()
					elif line.startswith('sync_port='):
						try:
							config['port'] = int(line.split('=', 1)[1].strip())
						except ValueError:
							pass
					elif line.startswith('sync_enabled='):
						config['enabled'] = line.split('=', 1)[1].strip().lower() in ('true', '1', 'yes')
		except Exception:
			pass

	# Read user ID from installation directory
	if os.path.exists(USER_ID_FILE):
		try:
			with open(USER_ID_FILE, 'r') as f:
				for line in f:
					if line.startswith('user_id='):
						config['user_id'] = line.split('=', 1)[1].strip()
						break
		except Exception:
			pass

	return config

def save_sync_config(enabled, server, port):
	"""Save sync configuration to main config file.

	Args:
		enabled (bool): Whether sync is enabled
		server (str): Sync server hostname/IP
		port (int): Sync server port
	"""
	# Read existing config
	config_lines = []
	if os.path.exists(CONFIG_FILE):
		try:
			with open(CONFIG_FILE, 'r') as f:
				config_lines = f.readlines()
		except Exception:
			pass

	# Update sync settings
	sync_settings = {
		'sync_enabled': str(enabled).lower(),
		'sync_server': server,
		'sync_port': str(port)
	}

	# Remove existing sync settings
	config_lines = [line for line in config_lines
	               if not any(line.strip().startswith(f'{key}=') for key in sync_settings.keys())]

	# Add updated sync settings
	for key, value in sync_settings.items():
		config_lines.append(f'{key}={value}\n')

	# Write updated config
	try:
		with open(CONFIG_FILE, 'w') as f:
			f.writelines(config_lines)
	except Exception as e:
		show_notification(f"Failed to save sync configuration: {e}")

def is_sync_enabled():
	"""Check if sync is enabled.

	Returns:
		bool: True if sync is enabled and properly configured
	"""
	config = get_sync_config()
	return config['enabled'] and config['user_id'] is not None

def upload_bookmarks():
	"""Upload current bookmarks to sync server.

	Returns:
		str or None: Sync ID if successful, None if failed
	"""
	if not is_sync_enabled():
		show_notification("Sync is not enabled or configured.")
		return None

	config = get_sync_config()

	try:
		# Read bookmarks file
		if not os.path.exists(BOOKMARKS_FILE):
			show_notification("No bookmarks file found to upload.")
			return None

		with open(BOOKMARKS_FILE, 'r') as f:
			content = f.read()

		# Upload to server
		url = f"http://{config['server']}:{config['port']}/upload"
		headers = {'X-User-ID': config['user_id']}

		response = requests.post(url, data=content, headers=headers, timeout=10)

		if response.status_code == 200:
			sync_id = response.text.strip()
			show_notification(f"Bookmarks uploaded successfully!\nSync ID: {sync_id}")
			return sync_id
		else:
			show_notification(f"Upload failed: {response.status_code} - {response.text}")
			return None

	except requests.exceptions.RequestException as e:
		show_notification(f"Network error during upload: {e}")
		return None
	except Exception as e:
		show_notification(f"Error uploading bookmarks: {e}")
		return None

def download_bookmarks(sync_id):
	"""Download bookmarks from sync server.

	Args:
		sync_id (str): Sync ID to download

	Returns:
		bool: True if successful, False if failed
	"""
	if not is_sync_enabled():
		show_notification("Sync is not enabled or configured.")
		return False

	config = get_sync_config()

	# Validate sync ID format
	if not sync_id or len(sync_id) != 8 or not all(c in '0123456789abcdef' for c in sync_id.lower()):
		show_notification("Invalid sync ID format. Must be 8 hexadecimal characters.")
		return False

	try:
		# Download from server
		url = f"http://{config['server']}:{config['port']}/download/{sync_id.lower()}"
		headers = {'X-User-ID': config['user_id']}

		response = requests.get(url, headers=headers, timeout=10)

		if response.status_code == 200:
			content = response.text

			# Backup existing bookmarks
			if os.path.exists(BOOKMARKS_FILE):
				backup_file = f"{BOOKMARKS_FILE}.backup"
				try:
					with open(BOOKMARKS_FILE, 'r') as src, open(backup_file, 'w') as dst:
						dst.write(src.read())
				except Exception:
					pass  # Backup failed, but continue

			# Write new bookmarks
			with open(BOOKMARKS_FILE, 'w') as f:
				f.write(content)

			show_notification("Bookmarks downloaded and applied successfully!")
			return True
		elif response.status_code == 404:
			show_notification("Sync ID not found. Please check the ID and try again.")
			return False
		else:
			show_notification(f"Download failed: {response.status_code} - {response.text}")
			return False

	except requests.exceptions.RequestException as e:
		show_notification(f"Network error during download: {e}")
		return False
	except Exception as e:
		show_notification(f"Error downloading bookmarks: {e}")
		return False

def test_sync_connection():
	"""Test connection to sync server.

	Returns:
		bool: True if server is reachable, False otherwise
	"""
	config = get_sync_config()

	try:
		url = f"http://{config['server']}:{config['port']}/status"
		response = requests.get(url, timeout=5)
		return response.status_code == 200
	except Exception:
		return False
</file>

<file path="src/sync_service/sync_service.js">
const http = require('http');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const DATA_DIR = '/var/ssh-tray-sync';
const PORT = 9182;

// Ensure data directory exists
if (!fs.existsSync(DATA_DIR)) {
	fs.mkdirSync(DATA_DIR, { recursive: true });
	console.log(`Created data directory: ${DATA_DIR}`);
}

const server = http.createServer((req, res) => {
	// Enable CORS for web requests
	res.setHeader('Access-Control-Allow-Origin', '*');
	res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
	res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-User-ID');
	
	// Handle OPTIONS preflight requests
	if (req.method === 'OPTIONS') {
		res.writeHead(200);
		res.end();
		return;
	}
	
	const timestamp = new Date().toISOString();
	console.log(`${timestamp} - ${req.method} ${req.url} from ${req.connection.remoteAddress}`);
	
	if (req.method === 'POST' && req.url === '/upload') {
		// Upload bookmark configuration
		const userId = req.headers['x-user-id'];
		if (!userId || !/^[a-f0-9]{16}$/.test(userId)) {
			res.writeHead(400, {'Content-Type': 'text/plain'});
			res.end('Invalid or missing user ID');
			return;
		}
		
		let body = '';
		req.on('data', chunk => {
			body += chunk;
			// Prevent huge uploads (max 64KB for config files)
			if (body.length > 65536) {
				res.writeHead(413, {'Content-Type': 'text/plain'});
				res.end('File too large');
				req.destroy();
				return;
			}
		});
		
		req.on('end', () => {
			try {
				// Generate sync ID and create filename with user prefix
				const syncId = crypto.randomBytes(4).toString('hex');
				const fileName = `${userId}_${syncId}.txt`;
				const filePath = path.join(DATA_DIR, fileName);
				
				// Write the configuration file
				fs.writeFileSync(filePath, body, 'utf8');
				
				console.log(`Uploaded config for user ${userId}, sync ID: ${syncId}`);
				res.writeHead(200, {'Content-Type': 'text/plain'});
				res.end(syncId);
			} catch (error) {
				console.error('Upload error:', error);
				res.writeHead(500, {'Content-Type': 'text/plain'});
				res.end('Server error');
			}
		});
		
		req.on('error', (error) => {
			console.error('Request error:', error);
			res.writeHead(400);
			res.end('Bad request');
		});
	} 
	else if (req.method === 'GET' && req.url.startsWith('/download/')) {
		// Download bookmark configuration
		const urlParts = req.url.split('/');
		if (urlParts.length !== 3) {
			res.writeHead(400, {'Content-Type': 'text/plain'});
			res.end('Invalid URL format');
			return;
		}
		
		const syncId = urlParts[2];
		const userId = req.headers['x-user-id'];
		
		if (!userId || !/^[a-f0-9]{16}$/.test(userId)) {
			res.writeHead(400, {'Content-Type': 'text/plain'});
			res.end('Invalid or missing user ID');
			return;
		}
		
		if (!/^[a-f0-9]{8}$/.test(syncId)) {
			res.writeHead(400, {'Content-Type': 'text/plain'});
			res.end('Invalid sync ID format');
			return;
		}
		
		const fileName = `${userId}_${syncId}.txt`;
		const filePath = path.join(DATA_DIR, fileName);
		
		try {
			if (fs.existsSync(filePath)) {
				const content = fs.readFileSync(filePath, 'utf8');
				console.log(`Downloaded config for user ${userId}, sync ID: ${syncId}`);
				res.writeHead(200, {'Content-Type': 'text/plain'});
				res.end(content);
			} else {
				console.log(`Config not found for user ${userId}, sync ID: ${syncId}`);
				res.writeHead(404, {'Content-Type': 'text/plain'});
				res.end('Configuration not found');
			}
		} catch (error) {
			console.error('Download error:', error);
			res.writeHead(500, {'Content-Type': 'text/plain'});
			res.end('Server error');
		}
	}
	else if (req.method === 'GET' && req.url === '/status') {
		// Health check endpoint
		const fileCount = fs.readdirSync(DATA_DIR).length;
		res.writeHead(200, {'Content-Type': 'application/json'});
		res.end(JSON.stringify({
			status: 'online',
			port: PORT,
			files: fileCount,
			uptime: process.uptime()
		}));
	}
	else {
		res.writeHead(404, {'Content-Type': 'text/plain'});
		res.end('Endpoint not found');
	}
});

// Error handling
server.on('error', (error) => {
	console.error('Server error:', error);
});

// Graceful shutdown
process.on('SIGINT', () => {
	console.log('\nShutting down SSH Tray Sync service...');
	server.close(() => {
		console.log('Server closed.');
		process.exit(0);
	});
});

server.listen(PORT, '0.0.0.0', () => {
	console.log(`SSH Tray Sync service running on port ${PORT}`);
	console.log(`Data directory: ${DATA_DIR}`);
	console.log('Endpoints:');
	console.log('  POST /upload - Upload configuration');
	console.log('  GET /download/{syncId} - Download configuration');
	console.log('  GET /status - Service status');
});
</file>

<file path="test/.user_id">
user_id=a1b2c3d4e5f6789a
</file>

<file path="test/service-test.sh">
#!/bin/bash
SERVER="10.10.11.166:9182"
USER_ID="a1b2c3d4e5f6789a"  # 16 hex chars

echo "Testing SSH Tray Sync Service at $SERVER..."
echo "User ID: $USER_ID (length: ${#USER_ID})"

# Test status
echo -e "\n1. Testing status endpoint..."
curl -s http://$SERVER/status && echo

# Create test data
echo -e "\n2. Creating test data..."
TEST_DATA="# Test bookmarks
------ Test Servers ------
Test Server	user@10.10.11.100
Another Test	root@test.local"

echo "Test data created."

# Test upload
echo -e "\n3. Testing upload..."
echo "Sending User-ID: $USER_ID"
SYNC_ID=$(echo "$TEST_DATA" | curl -s -X POST -H "X-User-ID: $USER_ID" --data-binary @- http://$SERVER/upload)
echo "Response: '$SYNC_ID'"

if [[ ${#SYNC_ID} -eq 8 ]]; then
    echo "✓ Upload successful! Sync ID: $SYNC_ID"
    
    # Test download
    echo -e "\n4. Testing download..."
    DOWNLOADED=$(curl -s -H "X-User-ID: $USER_ID" http://$SERVER/download/$SYNC_ID)
    echo "Downloaded content:"
    echo "$DOWNLOADED"
    
    if [[ "$DOWNLOADED" == "$TEST_DATA" ]]; then
        echo "✓ Download successful! Data matches."
    else
        echo "✗ Download failed or data mismatch."
    fi
else
    echo "✗ Upload failed: $SYNC_ID"
fi

echo -e "\nTest complete!"
</file>

<file path="test/sync-module-test.sh">
#!/bin/bash
# sync-module-test.sh - Test Python sync module from test/ directory

echo "Testing SSH Tray Python sync module from test directory..."

# Go up one level to the ssh-tray root
cd ..

echo "Using SSH Tray directory: $(pwd)"

# Test the sync module
python3 -c "
import sys
sys.path.insert(0, 'src')

try:
    from ssh_tray.sync import get_sync_config, test_sync_connection
    
    print('Getting sync config...')
    config = get_sync_config()
    print(f'Config: {config}')
    
    if config['enabled'] and config['user_id']:
        print('Testing connection...')
        result = test_sync_connection()
        print(f'Connection test: {\"✓ SUCCESS\" if result else \"✗ FAILED\"}')
    else:
        print('Sync not enabled or user_id missing')
        print(f'  enabled: {config[\"enabled\"]}')
        print(f'  user_id: {config[\"user_id\"]}')
        
except ImportError as e:
    print(f'Import error: {e}')
except Exception as e:
    print(f'Error: {e}')
"
</file>

<file path="test/test-bookmarks.txt">
# Test SSH bookmarks
------ Development ------
Test Serveruser@test.example.com
Local VMroot@192.168.1.100

------ Production ------
Web Serverdeploy@prod.example.com
</file>

<file path="archive/ssh_tray.old.py">
#!/usr/bin/env python3
"""
===============================================================================
SSH Bookmark Manager
Company:    Infoproject LLC, North Macedonia
Developer:  Vanco Ordanoski - vordan@infoproject.biz
Support:    support@infoproject.biz

License:    MIT License (see below)
-------------------------------------------------------------------------------
Description:
    SSH Bookmark Manager is a Linux tray application for managing SSH bookmarks.
    - Provides a tray menu with one-click SSH access to saved hosts/groups.
    - Supports bookmarks grouping, reorder, easy add/edit/delete, and configuration.
    - Configurable terminal emulator support (mate-terminal, gnome-terminal, etc.).
    - Bookmarks and config are saved as simple text files in your home folder.
    - Autostart and .desktop launcher integration are supported.
    - Designed for Linux Mint/Ubuntu/Cinnamon/MATE/XFCE/other desktops.
-------------------------------------------------------------------------------
Usage:
    1. Run ./ssh_tray.py &
    2. Edit your SSH bookmarks and terminal preferences from the tray menu.
    3. Use the tray icon to launch SSH sessions in your chosen terminal.
    4. Optionally, enable autostart and add a menu shortcut.

Files:
    - ~/.ssh_bookmarks      List of bookmarks (one per line; group lines supported)
    - ~/.ssh_tray_config    Terminal emulator and settings (see examples)
    - ~/.config/autostart/ssh_tray.desktop (autostart link, if enabled)
    - ~/.local/share/applications/ssh_tray.desktop (menu launcher, if added)

Dependencies:
    - Python 3.x
    - python3-gi (GTK and AppIndicator bindings)
    - Supported terminal emulator (mate-terminal, gnome-terminal, xfce4-terminal, etc.)

MIT License:
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
===============================================================================
"""

import gi
import subprocess
import os
import shutil

gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
from gi.repository import Gtk, AppIndicator3

BOOKMARKS_FILE = os.path.expanduser('~/.ssh_bookmarks')
CONFIG_FILE = os.path.expanduser('~/.ssh_tray_config')
DESKTOP_FILE = os.path.expanduser('~/.local/share/applications/ssh_tray.desktop')
AUTOSTART_DIR = os.path.expanduser('~/.config/autostart')
AUTOSTART_FILE = os.path.join(AUTOSTART_DIR, 'ssh_tray.desktop')

SUPPORTED_TERMINALS = [
	'mate-terminal', 'gnome-terminal', 'xfce4-terminal', 'tilix',
	'konsole', 'lxterminal', 'xterm'
]

ICON_NAME = 'network-server'

def ensure_config_files():
	created = False
	if not os.path.exists(CONFIG_FILE):
		with open(CONFIG_FILE, 'w') as f:
			f.write('terminal=mate-terminal\n')
		created = True
	if not os.path.exists(BOOKMARKS_FILE):
		with open(BOOKMARKS_FILE, 'w') as f:
			f.write('# Example SSH bookmarks:\n')
			f.write('------ Dev Servers ------\n')
			f.write('Dev 1 [10.10.10.98]\troot@10.10.10.98\n')
			f.write('Dev 2 [10.10.11.22]\troot@10.10.11.22\n')
			f.write('------ Production ------\n')
			f.write('Prod DB\tadmin@192.168.1.5\n')
		created = True
	return created

def show_instructions(parent=None):
	text = (
		"SSH Bookmark Manager Help\n\n"
		"Bookmarks: {}\n"
		"Config: {}\n\n"
		"How to use:\n"
		" - Each line in the bookmarks file is either:\n"
		"     * a bookmark: DESCRIPTION<tab>user@host[:port]\n"
		"     * a group header: a line with dashes, e.g. '------ Group Name ------'\n"
		" - Set your terminal in the config file (e.g. 'terminal=mate-terminal').\n"
		" - Edit everything using the tray editor, or a text editor if you prefer.\n"
		" - Use the tray icon to launch SSH, edit bookmarks, show help, or configure autostart.\n"
		" - For menu or autostart integration, see configuration in the tray menu."
	).format(BOOKMARKS_FILE, CONFIG_FILE)
	dialog = Gtk.MessageDialog(
		parent=parent, modal=True, message_type=Gtk.MessageType.INFO,
		buttons=Gtk.ButtonsType.OK, text="SSH Bookmark Manager - Instructions")
	dialog.format_secondary_text(text)
	dialog.set_border_width(20)
	dialog.connect("response", lambda d, r: d.destroy())
	dialog.connect("delete-event", lambda d, e: d.destroy() or False)
	dialog.show_all()
	dialog.run()
	dialog.destroy()

def available_terminals():
	return [t for t in SUPPORTED_TERMINALS if shutil.which(t)]

def read_config_terminal():
	terminal = 'mate-terminal'
	if os.path.exists(CONFIG_FILE):
		with open(CONFIG_FILE) as f:
			for line in f:
				line = line.strip()
				if line.startswith('terminal='):
					val = line.split('=', 1)[1].strip()
					if val:
						terminal = val
					break
	if not (os.path.isabs(terminal) and os.access(terminal, os.X_OK)) and shutil.which(terminal) is None:
		show_notification(f"Terminal '{terminal}' not found in PATH.\nPlease select or set a valid terminal in the configuration.")
		avail = available_terminals()
		if avail:
			terminal = avail[0]
		else:
			terminal = 'xterm'
	return terminal

def validate_bookmark_line(line):
	line = line.strip()
	if not line or line.startswith('#'):
		return None
	if line.startswith('-') and line.endswith('-') and len(line) > 3:
		return ('__GROUP__', line.strip('- ').strip())
	parts = line.rsplit(None, 1)
	if len(parts) == 2:
		label, ssh_target = parts
		if '@' in ssh_target:
			return (label, ssh_target)
	return None

def load_bookmarks():
	bookmarks = []
	errors = []
	if os.path.exists(BOOKMARKS_FILE):
		with open(BOOKMARKS_FILE, 'r') as f:
			for idx, line in enumerate(f):
				result = validate_bookmark_line(line)
				if result:
					bookmarks.append(result)
				elif line.strip() and not line.strip().startswith('#'):
					errors.append(f"Line {idx+1}: '{line.strip()}'")
	if errors:
		show_notification("Invalid lines in bookmarks file:\n" + "\n".join(errors))
	return bookmarks

def save_bookmarks(bookmarks):
	with open(BOOKMARKS_FILE, 'w') as f:
		for label, ssh_target in bookmarks:
			if label == '__GROUP__':
				f.write(f"------ {ssh_target} ------\n")
			else:
				f.write(f"{label}\t{ssh_target}\n")

def open_ssh_in_terminal(terminal, ssh_target, label):
	try:
		terminal_exec = terminal
		if os.path.isabs(terminal) and os.access(terminal, os.X_OK):
			pass
		else:
			terminal_exec = shutil.which(terminal) or terminal
		if 'mate-terminal' in terminal_exec:
			cmd = [
				terminal_exec, '--tab', '--title', label, '--',
				'bash', '-c', f'ssh {ssh_target}; exec bash'
			]
		elif 'xfce4-terminal' in terminal_exec:
			cmd = [
				terminal_exec, '--tab', '--title', label, '--command',
				f'ssh {ssh_target}'
			]
		elif 'gnome-terminal' in terminal_exec:
			cmd = [
				terminal_exec, '--tab', '--title', label, '--', 'ssh', ssh_target
			]
		elif 'xterm' in terminal_exec:
			cmd = [
				terminal_exec, '-T', label, '-e', f'ssh {ssh_target}'
			]
		else:
			cmd = [terminal_exec, '-e', f'ssh {ssh_target}']
		subprocess.Popen(cmd)
	except Exception as e:
		show_notification(f"Failed to launch terminal.\n{e}")

def create_desktop_file(exec_path):
	contents = f"""[Desktop Entry]
Type=Application
Name=SSH Bookmark Manager
Exec={exec_path}
Icon={ICON_NAME}
Terminal=false
Categories=Utility;Network;
Comment=SSH tray bookmarks and launcher
"""
	os.makedirs(os.path.dirname(DESKTOP_FILE), exist_ok=True)
	with open(DESKTOP_FILE, 'w') as f:
		f.write(contents)
	os.chmod(DESKTOP_FILE, 0o755)

def add_to_autostart(enable=True):
	if enable:
		os.makedirs(AUTOSTART_DIR, exist_ok=True)
		shutil.copy(DESKTOP_FILE, AUTOSTART_FILE)
	else:
		if os.path.exists(AUTOSTART_FILE):
			os.remove(AUTOSTART_FILE)

def is_autostart_enabled():
	return os.path.exists(AUTOSTART_FILE)

def show_notification(message, parent=None):
	dialog = Gtk.MessageDialog(
		parent=parent, modal=True, message_type=Gtk.MessageType.INFO,
		buttons=Gtk.ButtonsType.OK, text=message)
	dialog.set_border_width(20)
	dialog.connect("response", lambda d, r: d.destroy())
	dialog.connect("delete-event", lambda d, e: d.destroy() or False)
	dialog.show_all()
	dialog.run()
	dialog.destroy()

class EditBookmarksDialog(Gtk.Dialog):
	def __init__(self, parent, bookmarks, terminal, on_change_callback):
		Gtk.Dialog.__init__(self, title="Edit SSH Bookmarks and Configuration", transient_for=parent, modal=True)
		self.set_border_width(20)
		self.set_default_size(650, 500)
		self.bookmarks = [list(item) for item in bookmarks]
		self.terminal = terminal
		self.on_change_callback = on_change_callback

		box = self.get_content_area()

		# Subtitle
		subtitle = Gtk.Label()
		subtitle.set_text(
			"Here you can add, remove, group, and reorder SSH bookmarks, and configure your terminal and autostart options.")
		subtitle.set_justify(Gtk.Justification.LEFT)
		subtitle.set_halign(Gtk.Align.START)
		subtitle.set_margin_top(16)
		subtitle.set_margin_bottom(16)
		box.pack_start(subtitle, False, False, 0)

		# Terminal selector section
		term_box = Gtk.Box(spacing=6)
		term_label = Gtk.Label(label="Terminal:")
		self.term_combo = Gtk.ComboBoxText()
		for t in available_terminals():
			self.term_combo.append_text(t)
		self.term_combo.set_active(
			available_terminals().index(self.terminal)
			if self.terminal in available_terminals() else -1)
		self.term_entry = Gtk.Entry()
		self.term_entry.set_text(self.terminal)
		self.term_combo.connect("changed", self.on_term_combo_changed)
		term_box.pack_start(term_label, False, False, 0)
		term_box.pack_start(self.term_combo, False, False, 0)
		term_box.pack_start(self.term_entry, True, True, 0)
		save_icon = Gtk.Image.new_from_icon_name("document-save", Gtk.IconSize.BUTTON)
		save_btn = Gtk.Button()
		save_btn.set_image(save_icon)
		save_btn.set_tooltip_text("Save terminal")
		save_btn.connect("clicked", self.on_save_terminal)
		help_icon = Gtk.Image.new_from_icon_name("help-about", Gtk.IconSize.BUTTON)
		help_btn = Gtk.Button()
		help_btn.set_image(help_icon)
		help_btn.set_tooltip_text("Help: Supported terminals")
		help_btn.connect("clicked", self.on_help_terminal)
		term_box.pack_start(save_btn, False, False, 0)
		term_box.pack_start(help_btn, False, False, 0)
		box.pack_start(term_box, False, False, 10)

		# TreeView for bookmarks/groups
		self.liststore = Gtk.ListStore(str, str)
		for label, target in self.bookmarks:
			self.liststore.append([label, target])
		self.treeview = Gtk.TreeView(model=self.liststore)
		renderer_text = Gtk.CellRendererText()
		column_label = Gtk.TreeViewColumn("Description / Group", renderer_text, text=0)
		column_target = Gtk.TreeViewColumn("SSH Target", renderer_text, text=1)
		self.treeview.append_column(column_label)
		self.treeview.append_column(column_target)
		scrolled_window = Gtk.ScrolledWindow()
		scrolled_window.set_border_width(5)
		scrolled_window.set_vexpand(True)
		scrolled_window.add(self.treeview)
		box.pack_start(scrolled_window, True, True, 10)

		# Add/Edit/Delete/Group/Up/Down buttons, all with icons
		button_box = Gtk.Box(spacing=8)
		self.add_btn = Gtk.Button()
		self.add_btn.set_image(Gtk.Image.new_from_icon_name("list-add", Gtk.IconSize.BUTTON))
		self.add_btn.set_tooltip_text("Add bookmark")
		self.add_btn.connect("clicked", self.on_add)

		self.edit_btn = Gtk.Button()
		self.edit_btn.set_image(Gtk.Image.new_from_icon_name("document-edit", Gtk.IconSize.BUTTON))
		self.edit_btn.set_tooltip_text("Edit selected")
		self.edit_btn.connect("clicked", self.on_edit)

		self.del_btn = Gtk.Button()
		self.del_btn.set_image(Gtk.Image.new_from_icon_name("edit-delete", Gtk.IconSize.BUTTON))
		self.del_btn.set_tooltip_text("Delete selected")
		self.del_btn.connect("clicked", self.on_delete)

		self.grp_btn = Gtk.Button()
		self.grp_btn.set_image(Gtk.Image.new_from_icon_name("folder-new", Gtk.IconSize.BUTTON))
		self.grp_btn.set_tooltip_text("Add group")
		self.grp_btn.connect("clicked", self.on_add_group)

		self.up_btn = Gtk.Button()
		self.up_btn.set_image(Gtk.Image.new_from_icon_name("go-up", Gtk.IconSize.BUTTON))
		self.up_btn.set_tooltip_text("Move up")
		self.up_btn.connect("clicked", self.on_move_up)

		self.down_btn = Gtk.Button()
		self.down_btn.set_image(Gtk.Image.new_from_icon_name("go-down", Gtk.IconSize.BUTTON))
		self.down_btn.set_tooltip_text("Move down")
		self.down_btn.connect("clicked", self.on_move_down)

		for btn in [self.add_btn, self.edit_btn, self.del_btn, self.grp_btn, self.up_btn, self.down_btn]:
			button_box.pack_start(btn, False, False, 0)
		box.pack_start(button_box, False, False, 10)

		# Autostart and desktop integration
		opt_box = Gtk.Box(spacing=8)
		self.autostart_switch = Gtk.Switch()
		self.autostart_switch.set_active(is_autostart_enabled())
		self.autostart_switch.connect("notify::active", self.on_autostart_toggle)
		opt_box.pack_start(Gtk.Label(label="Autostart:"), False, False, 0)
		opt_box.pack_start(self.autostart_switch, False, False, 0)
		desktop_btn = Gtk.Button()
		desktop_btn.set_image(Gtk.Image.new_from_icon_name("applications-internet", Gtk.IconSize.BUTTON))
		desktop_btn.set_tooltip_text("Add to Menu (.desktop)")
		desktop_btn.connect("clicked", self.on_add_to_menu)
		opt_box.pack_start(desktop_btn, False, False, 0)
		box.pack_start(opt_box, False, False, 8)

		self.show_all()

	def _save_and_refresh(self):
		bookmarks = self.get_bookmarks()
		save_bookmarks(bookmarks)
		if self.on_change_callback:
			self.on_change_callback()
		return bookmarks

	def on_term_combo_changed(self, combo):
		text = combo.get_active_text()
		if text:
			self.term_entry.set_text(text)

	def on_save_terminal(self, button):
		terminal = self.term_entry.get_text().strip()
		if not terminal:
			show_notification("Please enter a terminal command.", parent=self)
			return
		with open(CONFIG_FILE, 'w') as f:
			f.write(f'terminal={terminal}\n')
		self.terminal = terminal
		show_notification(f"Terminal set to '{terminal}'.", parent=self)

	def on_help_terminal(self, button):
		text = (
			"Supported terminals:\n"
			"  mate-terminal, gnome-terminal, xfce4-terminal, tilix, konsole, lxterminal, xterm\n"
			"You can also enter a full path or custom terminal command. The terminal must be in your $PATH."
		)
		show_notification(text, parent=self)

	def on_add(self, button):
		dialog = Gtk.Dialog(
			title="Add Bookmark", transient_for=self, modal=True)
		dialog.set_border_width(20)
		dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
						   Gtk.STOCK_OK, Gtk.ResponseType.OK)
		box = dialog.get_content_area()
		label_entry = Gtk.Entry()
		label_entry.set_placeholder_text("Description")
		target_entry = Gtk.Entry()
		target_entry.set_placeholder_text("user@host[:port]")
		box.pack_start(Gtk.Label(label="Description:"), False, False, 0)
		box.pack_start(label_entry, False, False, 0)
		box.pack_start(Gtk.Label(label="SSH Target:"), False, False, 0)
		box.pack_start(target_entry, False, False, 0)
		box.set_border_width(20)
		dialog.show_all()
		resp = dialog.run()
		if resp == Gtk.ResponseType.OK:
			label = label_entry.get_text().strip()
			target = target_entry.get_text().strip()
			if label and target and '@' in target:
				self.liststore.append([label, target])
				self._save_and_refresh()
		dialog.destroy()

	def on_edit(self, button):
		selection = self.treeview.get_selection()
		model, treeiter = selection.get_selected()
		if treeiter:
			label_old = model[treeiter][0]
			target_old = model[treeiter][1]
			if label_old == '__GROUP__':
				dialog = Gtk.Dialog(
					title="Edit Group", transient_for=self, modal=True)
				dialog.set_border_width(20)
				dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
								   Gtk.STOCK_OK, Gtk.ResponseType.OK)
				box = dialog.get_content_area()
				label_entry = Gtk.Entry()
				label_entry.set_text(target_old)
				box.pack_start(Gtk.Label(label="Group Name:"), False, False, 0)
				box.pack_start(label_entry, False, False, 0)
				box.set_border_width(20)
				dialog.show_all()
				resp = dialog.run()
				if resp == Gtk.ResponseType.OK:
					label = label_entry.get_text().strip()
					if label:
						model[treeiter][1] = label
						self._save_and_refresh()
				dialog.destroy()
			else:
				dialog = Gtk.Dialog(
					title="Edit Bookmark", transient_for=self, modal=True)
				dialog.set_border_width(20)
				dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
								   Gtk.STOCK_OK, Gtk.ResponseType.OK)
				box = dialog.get_content_area()
				label_entry = Gtk.Entry()
				label_entry.set_text(label_old)
				target_entry = Gtk.Entry()
				target_entry.set_text(target_old)
				box.pack_start(Gtk.Label(label="Description:"), False, False, 0)
				box.pack_start(label_entry, False, False, 0)
				box.pack_start(Gtk.Label(label="SSH Target:"), False, False, 0)
				box.pack_start(target_entry, False, False, 0)
				box.set_border_width(20)
				dialog.show_all()
				resp = dialog.run()
				if resp == Gtk.ResponseType.OK:
					label = label_entry.get_text().strip()
					target = target_entry.get_text().strip()
					if label and target and '@' in target:
						model[treeiter][0] = label
						model[treeiter][1] = target
						self._save_and_refresh()
				dialog.destroy()

	def on_delete(self, button):
		selection = self.treeview.get_selection()
		model, treeiter = selection.get_selected()
		if treeiter:
			model.remove(treeiter)
			self._save_and_refresh()

	def on_add_group(self, button):
		dialog = Gtk.Dialog(
			title="Add Group", transient_for=self, modal=True)
		dialog.set_border_width(20)
		dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
						   Gtk.STOCK_OK, Gtk.ResponseType.OK)
		box = dialog.get_content_area()
		label_entry = Gtk.Entry()
		label_entry.set_placeholder_text("Group Name")
		box.pack_start(Gtk.Label(label="Group Name:"), False, False, 0)
		box.pack_start(label_entry, False, False, 0)
		box.set_border_width(20)
		dialog.show_all()
		resp = dialog.run()
		if resp == Gtk.ResponseType.OK:
			label = label_entry.get_text().strip()
			if label:
				self.liststore.append(['__GROUP__', label])
				self._save_and_refresh()
		dialog.destroy()

	def on_move_up(self, button):
		selection = self.treeview.get_selection()
		model, treeiter = selection.get_selected()
		if treeiter:
			path = model.get_path(treeiter)
			index = path.get_indices()[0]
			if index > 0:
				model.insert(index - 1, list(model[treeiter]))
				model.remove(treeiter)
				iter_moved = model.get_iter(index - 1)
				self.treeview.get_selection().select_iter(iter_moved)
				self._save_and_refresh()

	def on_move_down(self, button):
		selection = self.treeview.get_selection()
		model, treeiter = selection.get_selected()
		if treeiter:
			path = model.get_path(treeiter)
			index = path.get_indices()[0]
			if index < len(model) - 1:
				model.insert(index + 2, list(model[treeiter]))
				model.remove(treeiter)
				iter_moved = model.get_iter(index + 1)
				self.treeview.get_selection().select_iter(iter_moved)
				self._save_and_refresh()

	def get_bookmarks(self):
		return [(row[0], row[1]) for row in self.liststore]

	def on_add_to_menu(self, button):
		exec_path = os.path.abspath(__file__)
		create_desktop_file(exec_path)
		show_notification("Added SSH Bookmark Manager to menu.", parent=self)

	def on_autostart_toggle(self, switch, gparam):
		if switch.get_active():
			add_to_autostart(True)
			show_notification("Autostart enabled.", parent=self)
		else:
			add_to_autostart(False)
			show_notification("Autostart disabled.", parent=self)

class SSHTrayApp:
	def __init__(self):
		self.terminal = read_config_terminal()
		self.app = AppIndicator3.Indicator.new(
			'ssh-bookmarks', ICON_NAME,
			AppIndicator3.IndicatorCategory.APPLICATION_STATUS)
		self.app.set_status(AppIndicator3.IndicatorStatus.ACTIVE)
		self.app.set_title("Open SSH connection")
		self.menu = Gtk.Menu()
		self.build_menu()
		self.app.set_menu(self.menu)

	def build_menu(self):
		self.menu.foreach(lambda widget: self.menu.remove(widget))
		bookmarks = load_bookmarks()
		for label, target in bookmarks:
			if label == '__GROUP__':
				item = Gtk.MenuItem(label=target)
				item.set_sensitive(False)
				item.get_child().set_markup(f'<b>{target}</b>')
				self.menu.append(item)
			else:
				item = Gtk.MenuItem(label=label)
				item.connect('activate', self.on_bookmark_activate, target, label)
				self.menu.append(item)
		self.menu.append(Gtk.SeparatorMenuItem())
		edit_item = Gtk.MenuItem(label="Edit bookmarks/config")
		edit_item.connect('activate', self.on_edit_bookmarks)
		self.menu.append(edit_item)
		instr_item = Gtk.MenuItem(label="Show instructions")
		instr_item.connect('activate', self.on_show_instructions)
		self.menu.append(instr_item)
		self.menu.append(Gtk.SeparatorMenuItem())
		quit_item = Gtk.MenuItem(label="Quit")
		quit_item.connect('activate', self.quit)
		self.menu.append(quit_item)
		self.menu.show_all()

	def on_bookmark_activate(self, widget, target, label):
		open_ssh_in_terminal(self.terminal, target, label)

	def on_edit_bookmarks(self, widget):
		def refresh_menu():
			self.terminal = read_config_terminal()
			self.build_menu()
		bookmarks = load_bookmarks()
		dialog = EditBookmarksDialog(None, bookmarks, self.terminal, on_change_callback=refresh_menu)
		dialog.run()
		dialog.destroy()

	def on_show_instructions(self, widget):
		show_instructions()

	def quit(self, widget):
		Gtk.main_quit()

def main():
	created = ensure_config_files()
	app = SSHTrayApp()
	if created:
		show_instructions()
	Gtk.main()

if __name__ == '__main__':
	main()
</file>

<file path="config/ssh-bookmarks.sample.txt">
# SSH Bookmark Manager - Sample Bookmarks File
# Copy this to ~/.ssh-bookmarks and customize for your servers
#
# Format:
#   - Bookmarks: DESCRIPTION<tab>user@host[:port]
#   - Groups: ------ Group Name ------
#   - Comments: Lines starting with #
#
# Example bookmarks:

------ Development Servers ------
Dev Server 1	root@192.168.1.10
Dev Server 2	admin@192.168.1.11
Database Dev	postgres@192.168.1.20:5432

------ Production Servers ------
Web Server	www-data@prod.example.com
Database	admin@db.example.com
Load Balancer	root@lb.example.com

------ Personal Servers ------
Home Server	user@home.example.com:2222
VPS Instance	root@vps.example.com
Backup Server	backup@backup.example.com

------ Client Sites ------
Client A Web	deploy@clienta.com
Client A DB	root@db.clienta.com
Client B	admin@clientb.net

# You can also use IP addresses with custom ports:
# My Router	admin@192.168.1.1:22
# Custom Port Server	user@server.com:2200

# Tips:
# - Keep descriptions short but descriptive
# - Group related servers together
# - Use consistent naming conventions
# - Test connections manually before adding bookmarks
</file>

<file path="config/ssh-tray-config.sample.txt">
# SSH Bookmark Manager - Sample Configuration File
# Copy this to ~/.ssh-tray-config and customize for your system
#
# This file contains settings for the SSH Bookmark Manager application.

# Terminal Emulator Setting
# Specify which terminal emulator to use for SSH connections
# Supported terminals: mate-terminal, gnome-terminal, xfce4-terminal, tilix, konsole, lxterminal, xterm
# You can also specify a full path to a custom terminal
terminal=mate-terminal

# Examples for different desktop environments:
# terminal=gnome-terminal    # For GNOME desktop
# terminal=xfce4-terminal    # For XFCE desktop
# terminal=mate-terminal     # For MATE desktop
# terminal=konsole           # For KDE desktop
# terminal=tilix             # For modern GTK terminal
# terminal=lxterminal        # For LXDE desktop
# terminal=xterm             # Fallback terminal

# Custom terminal examples:
# terminal=/usr/bin/gnome-terminal
# terminal=/opt/custom-terminal/bin/terminal
# terminal=kitty             # If kitty terminal is in PATH

# Notes:
# - The terminal must be installed and available in your PATH
# - If the specified terminal is not found, the application will try to use a fallback
# - Some terminals may have different command-line argument formats
# - Test your terminal choice by running it manually before configuring
</file>

<file path="config/ssh-tray-uninstall.desktop">
[Desktop Entry]
Type=Application
Name=Uninstall SSH Bookmark Manager
Exec=ssh-tray --uninstall
Icon=application-exit
Terminal=true
Categories=System;Settings;
Comment=Remove SSH Bookmark Manager from your system
Keywords=uninstall;remove;ssh;bookmark;tray;
StartupNotify=false
NoDisplay=false
</file>

<file path="scripts/git_init.sh">
#!/bin/bash
# git_init.sh - Initialize SSH Bookmark Manager repository on GitHub
# This script clears the existing repo and creates a fresh one with the new structure

set -e

# --- Settings ---
GITHUB_USER="vordan"
REPO_NAME="ssh-tray"
GIT_EMAIL="vordan@infoproject.biz"
GIT_NAME="Vanco Ordanoski"
REPO_DESCRIPTION="SSH Bookmark Manager - Linux tray application for managing SSH bookmarks"
# ---------------

echo "==============================================================================="
echo "SSH Bookmark Manager - GitHub Repository Initialization"
echo "==============================================================================="
echo
echo "This script will:"
echo "  1. Delete the existing GitHub repository: $GITHUB_USER/$REPO_NAME"
echo "  2. Create a fresh new repository with the same name"
echo "  3. Initialize local git repository"
echo "  4. Make initial commit with the reorganized structure"
echo "  5. Push to GitHub as the main branch"
echo
echo "WARNING: This will permanently delete the existing repository and all its history!"
echo

# Function: yes/no confirmation prompt
function confirm() {
	while true; do
		read -r -p "$1 [Y/n] " answer
		case "$answer" in
			[Yy][Ee][Ss]|[Yy]|"") return 0 ;;
			[Nn][Oo]|[Nn]) return 1 ;;
			*) echo "Please answer Y or n." ;;
		esac
	done
}

# Check for GitHub CLI
if ! command -v gh >/dev/null 2>&1; then
	echo "ERROR: GitHub CLI (gh) is required but not installed."
	echo "Please install it first: sudo apt install gh"
	echo "Or run: ./scripts/github_cli_install.sh"
	exit 1
fi

# Auto-detect project root directory and change to it
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ "$(basename "$SCRIPT_DIR")" == "scripts" ]]; then
	# Running from scripts/ directory, go up one level
	PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
	echo "Detected running from scripts/ directory, changing to project root..."
	cd "$PROJECT_ROOT"
fi

# Check if we're in the right directory (should have src/ and scripts/)
if [[ ! -d "src" || ! -d "scripts" ]]; then
	echo "ERROR: Cannot find SSH Bookmark Manager project structure."
	echo "Expected to find src/ and scripts/ directories."
	echo "Current directory: $(pwd)"
	echo "Please run this script from the project root or scripts/ directory."
	exit 1
fi

echo "Working in project directory: $(pwd)"

# Confirm repository deletion
if ! confirm "Delete existing repository $GITHUB_USER/$REPO_NAME and create fresh one?"; then
	echo "Aborted by user."
	exit 1
fi

echo
echo "Setting up git configuration..."
git config --global user.name "$GIT_NAME"
git config --global user.email "$GIT_EMAIL"

# Add current directory as safe directory to avoid 'dubious ownership' warnings
CURRENT_DIR="$(pwd)"
echo "Adding current directory as git safe directory..."
git config --global --add safe.directory "$CURRENT_DIR"

echo "Checking if GitHub repository exists..."
if gh repo view "$GITHUB_USER/$REPO_NAME" >/dev/null 2>&1; then
	echo "Repository exists. Deleting existing GitHub repository..."
	if gh repo delete "$GITHUB_USER/$REPO_NAME" --confirm; then
		echo "✓ Repository deleted successfully"
		# Wait a moment for GitHub to process the deletion
		echo "Waiting for GitHub to process deletion..."
		sleep 3
	else
		echo "ERROR: Failed to delete repository. Please delete it manually:"
		echo "  https://github.com/$GITHUB_USER/$REPO_NAME/settings"
		echo "Or delete via CLI: gh repo delete $GITHUB_USER/$REPO_NAME --confirm"
		exit 1
	fi
else
	echo "ℹ Repository does not exist"
fi

echo "Creating new GitHub repository..."
if gh repo create "$GITHUB_USER/$REPO_NAME" --public --description "$REPO_DESCRIPTION"; then
	echo "✓ New repository created successfully"
else
	echo "ERROR: Failed to create repository. It may still exist or deletion is still processing."
	echo "Please wait a few minutes and try again, or delete manually first:"
	echo "  https://github.com/$GITHUB_USER/$REPO_NAME"
	exit 1
fi

echo "Initializing local git repository..."
# Remove any existing git directory
if [[ -d ".git" ]]; then
	rm -rf .git
fi

git init
echo "✓ Git repository initialized"

echo "Adding all files..."
git add .

echo "Creating initial commit..."
git commit -m "Initial commit: Reorganized SSH Bookmark Manager with modular structure

- Restructured as proper Python package in src/ssh_tray/
- Moved scripts to scripts/ directory
- Added sample configuration files in config/
- Updated installation to use /opt/ssh-tray (follows Linux FHS)
- Improved code documentation and organization
- Maintained original coding style and functionality
- Added proper package structure with __init__.py
- Fixed import statements for modular architecture
- Enhanced system integration and autostart features"

echo "Setting main branch..."
git branch -M main

echo "Adding remote origin..."
git remote add origin "https://github.com/$GITHUB_USER/$REPO_NAME.git"

echo "Pushing to GitHub..."
git push -u origin main

echo
echo "==============================================================================="
echo "✓ SUCCESS: Repository initialized and pushed to GitHub!"
echo "==============================================================================="
echo
echo "Repository URL: https://github.com/$GITHUB_USER/$REPO_NAME"
echo "Clone command: git clone https://github.com/$GITHUB_USER/$REPO_NAME.git"
echo
echo "Next steps:"
echo "  - View your repository: gh repo view --web"
echo "  - For future commits, use: ./scripts/git_commit.sh \"Your commit message\""
echo "  - Test the installation: ./scripts/install.sh"
echo
</file>

<file path="scripts/github_cli_install.sh">
#!/bin/bash
# github_cli_install.sh - Install GitHub CLI ('gh') for Ubuntu/Mint

set -e

if command -v gh >/dev/null 2>&1; then
	echo "GitHub CLI (gh) is already installed: $(gh --version | head -1)"
	exit 0
fi

echo "Trying to install GitHub CLI (gh) using the official apt repository..."

type -p curl >/dev/null || sudo apt install curl -y

if ! grep -q githubcli /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null; then
	curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | \
		sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
	sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
	echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | \
		sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
	sudo apt update
fi

if sudo apt install gh -y; then
	echo "GitHub CLI installed successfully (via apt)."
	gh --version
	exit 0
else
	echo "Apt installation failed. Trying to install via Snap..."
	if command -v snap >/dev/null 2>&1; then
		sudo snap install gh
		echo "GitHub CLI installed successfully (via snap)."
		gh --version
		exit 0
	else
		echo "Snap not available and apt install failed. Please install manually from https://github.com/cli/cli/releases"
		exit 1
	fi
fi
</file>

<file path="scripts/make_ssh_tray_project.sh">
#!/bin/bash

cat <<EOF
===============================================================================
make_ssh_tray_project.sh
------------------------
This script will:

 - Create a new project folder (default: ./ssh-tray) in your current directory.
 - Set up the proper directory structure with src/, scripts/, and archive/ folders.
 - Write all SSH Bookmark Manager source files into the appropriate locations.
 - This is for DEVELOPERS, packagers, or for preparing a project structure.
 - It does NOT install, run, or fetch files from the Internet.
 - You will be able to edit, ZIP, or upload the project to GitHub or other repositories.

No code will be executed outside the folder, and no symlinks or system files will be touched.

Are you sure you want to CONTINUE? [Y/n]
===============================================================================
EOF

read -r ok
case "$ok" in [nN]*) echo "Aborted."; exit 1;; esac

# Choose folder name
DEFAULT_DIR="ssh-tray"
echo
read -p "Enter directory for project output [${DEFAULT_DIR}]: " OUT_DIR
OUT_DIR="${OUT_DIR:-$DEFAULT_DIR}"

# Create directory structure
echo "Creating project structure in $(pwd)/$OUT_DIR ..."
mkdir -p "$OUT_DIR"/{src/ssh_tray,scripts,archive,config}
cd "$OUT_DIR"

# Create package __init__.py
cat > src/ssh_tray/__init__.py <<'EOF'
"""
SSH Bookmark Manager Package
============================

A Linux tray application for managing SSH bookmarks with group support,
configurable terminals, and desktop integration.

Author: Vanco Ordanoski
Company: Infoproject LLC, North Macedonia
License: MIT
"""

__version__ = "1.0.0"
__author__ = "Vanco Ordanoski"
__email__ = "vordan@infoproject.biz"
__company__ = "Infoproject LLC"
EOF

# Create main application module
cat > src/ssh_tray/main.py <<'EOF'
#!/usr/bin/env python3
"""
Main entry point for SSH Bookmark Manager tray application.
Manages the system tray icon, builds menus from bookmarks, and handles user interactions.
"""

import gi
gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
from gi.repository import Gtk, AppIndicator3

from .configuration import (
	read_config_terminal, ensure_config_files, load_bookmarks, show_instructions
)
from .system import (
	open_ssh_in_terminal, ICON_NAME
)
from .editor import EditBookmarksDialog

class SSHTrayApp:
	"""Main tray application class that manages the indicator and menu."""
	
	def __init__(self):
		"""Initialize the tray application with indicator and menu."""
		self.terminal = read_config_terminal()
		
		# Create the system tray indicator
		self.app = AppIndicator3.Indicator.new(
			'ssh-bookmarks', ICON_NAME,
			AppIndicator3.IndicatorCategory.APPLICATION_STATUS)
		self.app.set_status(AppIndicator3.IndicatorStatus.ACTIVE)
		self.app.set_title("Open SSH connection")
		
		# Initialize and build the context menu
		self.menu = Gtk.Menu()
		self.build_menu()
		self.app.set_menu(self.menu)

	def build_menu(self):
		"""Build the tray context menu from bookmarks and add control items."""
		# Clear existing menu items
		self.menu.foreach(lambda widget: self.menu.remove(widget))
		
		# Load bookmarks and create menu items
		bookmarks = load_bookmarks()
		for label, target in bookmarks:
			if label == '__GROUP__':
				# Create group header (disabled, bold text)
				item = Gtk.MenuItem(label=target)
				item.set_sensitive(False)
				item.get_child().set_markup(f'<b>{target}</b>')
				self.menu.append(item)
			else:
				# Create clickable bookmark item
				item = Gtk.MenuItem(label=label)
				item.connect('activate', self.on_bookmark_activate, target, label)
				self.menu.append(item)
		
		# Add separator and control menu items
		self.menu.append(Gtk.SeparatorMenuItem())
		
		edit_item = Gtk.MenuItem(label="Edit bookmarks/config")
		edit_item.connect('activate', self.on_edit_bookmarks)
		self.menu.append(edit_item)
		
		instr_item = Gtk.MenuItem(label="Show instructions")
		instr_item.connect('activate', self.on_show_instructions)
		self.menu.append(instr_item)
		
		self.menu.append(Gtk.SeparatorMenuItem())
		
		quit_item = Gtk.MenuItem(label="Quit")
		quit_item.connect('activate', self.quit)
		self.menu.append(quit_item)
		
		self.menu.show_all()

	def on_bookmark_activate(self, widget, target, label):
		"""Handle bookmark menu item click by opening SSH connection."""
		open_ssh_in_terminal(self.terminal, target, label)

	def on_edit_bookmarks(self, widget):
		"""Open the bookmark and configuration editor dialog."""
		def refresh_menu():
			"""Callback to refresh menu after changes."""
			self.terminal = read_config_terminal()
			self.build_menu()
		
		bookmarks = load_bookmarks()
		dialog = EditBookmarksDialog(None, bookmarks, self.terminal, on_change_callback=refresh_menu)
		dialog.run()
		dialog.destroy()

	def on_show_instructions(self, widget):
		"""Display help instructions dialog."""
		show_instructions()

	def quit(self, widget):
		"""Exit the application."""
		Gtk.main_quit()

def main():
	"""Main application entry point."""
	# Ensure configuration files exist, show help if first run
	created = ensure_config_files()
	
	# Create and run the tray application
	app = SSHTrayApp()
	
	# Show instructions on first run
	if created:
		show_instructions()
	
	# Start GTK main loop
	Gtk.main()

if __name__ == '__main__':
	main()
EOF

# Create remaining Python modules
cat > src/ssh_tray/configuration.py <<'EOF'
"""
Configuration and bookmarks management for SSH Tray.
Handles reading/writing config files, bookmark validation, and help text display.
"""

import os
import shutil
from .system import show_notification, available_terminals

# Configuration file paths in user's home directory
BOOKMARKS_FILE = os.path.expanduser('~/.ssh_bookmarks')
CONFIG_FILE = os.path.expanduser('~/.ssh_tray_config')

def ensure_config_files():
	"""Create default configuration files if they don't exist.
	
	Returns:
		bool: True if files were created (first run), False if they existed
	"""
	created = False
	
	# Create default terminal configuration
	if not os.path.exists(CONFIG_FILE):
		with open(CONFIG_FILE, 'w') as f:
			f.write('terminal=mate-terminal\n')
		created = True
	
	# Create example bookmarks file
	if not os.path.exists(BOOKMARKS_FILE):
		with open(BOOKMARKS_FILE, 'w') as f:
			f.write('# Example SSH bookmarks:\n')
			f.write('------ Dev Servers ------\n')
			f.write('Dev 1 [10.10.10.98]\troot@10.10.10.98\n')
			f.write('Dev 2 [10.10.11.22]\troot@10.10.11.22\n')
			f.write('------ Production ------\n')
			f.write('Prod DB\tadmin@192.168.1.5\n')
		created = True
	
	return created

# ... rest of configuration.py content ...
EOF

echo "Project structure created successfully in $(pwd)"
echo
echo "Directory structure:"
echo "  src/ssh_tray/     - Python package with application modules"
echo "  scripts/          - Installation and utility scripts"
echo "  archive/          - Old versions and backup files"
echo "  config/           - Sample configuration files"
echo
echo "Next steps:"
echo "  1. Complete the module files in src/ssh_tray/ with full implementations"
echo "  2. Add installation scripts to scripts/"
echo "  3. Create README.md, LICENSE.md in the root"
echo "  4. Test the application structure"
echo
echo "Note: This script creates a basic structure. You'll need to complete"
echo "the implementation of each module with the full source code."
</file>

<file path="src/ssh_tray/__init__.py">
"""
SSH Bookmark Manager Package
============================

A Linux tray application for managing SSH bookmarks with group support,
configurable terminals, and desktop integration.

Author: Vanco Ordanoski
Company: Infoproject LLC, North Macedonia
License: MIT
"""

__version__ = "1.0.0"
__author__ = "Vanco Ordanoski"
__email__ = "vordan@infoproject.biz"
__company__ = "Infoproject LLC"
</file>

<file path="src/ssh_tray/constants.py">
"""
SSH Bookmark Manager constants and configuration values.
"""

# Window and UI settings
DIALOG_BORDER_WIDTH = 20
DEFAULT_WINDOW_SIZE = (650, 500)
WIDGET_SPACING = 6
MARGIN_SIZE = 20

# File paths
SUPPORTED_TERMINALS = [
    'mate-terminal', 'gnome-terminal', 'xfce4-terminal', 'tilix',
    'konsole', 'lxterminal', 'xterm'
]

# Special markers
GROUP_MARKER = '__GROUP__'

# Icon names
ICON_NAMES = {
    'save': 'document-save',
    'help': 'help-about',
    'add': 'list-add',
    'edit': 'document-edit',
    'delete': 'edit-delete',
    'folder': 'folder-new',
    'up': 'go-up',
    'down': 'go-down',
    'app': 'applications-internet'
}
</file>

<file path="src/ssh_tray/dialogs.py">
"""
===============================================================================
ssh_tray.dialogs.py - Dialog components for SSH Bookmark Manager editor
Author: Vanco Ordanoski
MIT License

All dialog classes for adding/editing bookmarks, groups, and help information.
===============================================================================
"""

from gi.repository import Gtk
from .system import show_notification

class BookmarkDialog:
	"""Dialog for adding and editing SSH bookmarks."""
	
	def __init__(self, parent, title="Add Bookmark", label="", target=""):
		"""Initialize bookmark dialog.
		
		Args:
			parent: Parent window
			title: Dialog title
			label: Initial bookmark label (for editing)
			target: Initial SSH target (for editing)
		"""
		self.dialog = Gtk.Dialog(
			title=title, transient_for=parent, modal=True)
		self.dialog.set_border_width(20)
		self.dialog.add_buttons(
			Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
			Gtk.STOCK_OK, Gtk.ResponseType.OK)
		
		# Create form fields
		self._create_form(label, target)
		self.dialog.show_all()
	
	def _create_form(self, label, target):
		"""Create the form fields for bookmark entry."""
		box = self.dialog.get_content_area()
		
		# Description entry field
		self.label_entry = Gtk.Entry()
		self.label_entry.set_placeholder_text("Description")
		self.label_entry.set_text(label)
		
		# SSH target entry field
		self.target_entry = Gtk.Entry()
		self.target_entry.set_placeholder_text("user@host[:port]")
		self.target_entry.set_text(target)
		
		# Pack form elements
		box.pack_start(Gtk.Label(label="Description:"), False, False, 0)
		box.pack_start(self.label_entry, False, False, 0)
		box.pack_start(Gtk.Label(label="SSH Target:"), False, False, 0)
		box.pack_start(self.target_entry, False, False, 0)
		box.set_border_width(20)
	
	def run(self):
		"""Show dialog and return result.
		
		Returns:
			tuple: (response_type, label, target) or (CANCEL, None, None)
		"""
		response = self.dialog.run()
		
		if response == Gtk.ResponseType.OK:
			label = self.label_entry.get_text().strip()
			target = self.target_entry.get_text().strip()
			
			# Validate input - must have both fields and @ in target
			if label and target and '@' in target:
				return (response, label, target)
			else:
				return (Gtk.ResponseType.CANCEL, None, None)
		
		return (response, None, None)
	
	def destroy(self):
		"""Clean up dialog resources."""
		self.dialog.destroy()

class GroupDialog:
	"""Dialog for adding and editing bookmark groups."""
	
	def __init__(self, parent, title="Add Group", group_name=""):
		"""Initialize group dialog.
		
		Args:
			parent: Parent window
			title: Dialog title
			group_name: Initial group name (for editing)
		"""
		self.dialog = Gtk.Dialog(
			title=title, transient_for=parent, modal=True)
		self.dialog.set_border_width(20)
		self.dialog.add_buttons(
			Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
			Gtk.STOCK_OK, Gtk.ResponseType.OK)
		
		# Create form field
		self._create_form(group_name)
		self.dialog.show_all()
	
	def _create_form(self, group_name):
		"""Create the form field for group name entry."""
		box = self.dialog.get_content_area()
		
		# Group name entry field
		self.name_entry = Gtk.Entry()
		self.name_entry.set_placeholder_text("Group Name")
		self.name_entry.set_text(group_name)
		
		# Pack form elements
		box.pack_start(Gtk.Label(label="Group Name:"), False, False, 0)
		box.pack_start(self.name_entry, False, False, 0)
		box.set_border_width(20)
	
	def run(self):
		"""Show dialog and return result.
		
		Returns:
			tuple: (response_type, group_name) or (CANCEL, None)
		"""
		response = self.dialog.run()
		
		if response == Gtk.ResponseType.OK:
			group_name = self.name_entry.get_text().strip()
			if group_name:
				return (response, group_name)
		
		return (response, None)
	
	def destroy(self):
		"""Clean up dialog resources."""
		self.dialog.destroy()

def show_terminal_help(parent=None):
	"""Display help information about supported terminals.
	
	Args:
		parent: Parent window for modal dialog (optional)
	"""
	help_text = (
		"Supported terminals:\n"
		"  mate-terminal, gnome-terminal, xfce4-terminal, tilix, konsole, lxterminal, xterm\n\n"
		"You can also enter a full path or custom terminal command.\n"
		"The terminal must be installed and available in your $PATH.\n\n"
		"Examples:\n"
		"  mate-terminal (default)\n"
		"  /usr/bin/gnome-terminal\n"
		"  /opt/kitty/bin/kitty"
	)
	show_notification(help_text, parent=parent)
</file>

<file path="src/ssh_tray/main.py">
#!/usr/bin/env python3
"""
===============================================================================
ssh_tray.main.py - Main entry for SSH Bookmark Manager tray app
Company:    Infoproject LLC, North Macedonia
Developer:  Vanco Ordanoski - vordan@infoproject.biz
Support:    support@infoproject.biz
License:    MIT License

This is the main entry point for the SSH Bookmark Manager tray application.
===============================================================================
"""

import gi
import signal
import sys
gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
from gi.repository import Gtk, AppIndicator3, GLib

from .configuration import (
	read_config_terminal, ensure_config_files, load_bookmarks, show_instructions
)
from .system import (
	open_ssh_in_terminal, ICON_NAME
)
from .editor import EditBookmarksDialog

class SSHTrayApp:
	"""Main tray application class that manages the indicator and menu."""

	def __init__(self):
		"""Initialize the tray application with indicator and menu."""
		self.terminal = read_config_terminal()

		# Create the system tray indicator
		self.app = AppIndicator3.Indicator.new(
			'ssh-bookmarks', ICON_NAME,
			AppIndicator3.IndicatorCategory.APPLICATION_STATUS)
		self.app.set_status(AppIndicator3.IndicatorStatus.ACTIVE)
		self.app.set_title("Open SSH connection")

		# Initialize and build the context menu
		self.menu = Gtk.Menu()
		self.build_menu()
		self.app.set_menu(self.menu)

		# Set up signal handlers for graceful shutdown
		self._setup_signal_handlers()

	def _setup_signal_handlers(self):
		"""Set up signal handlers for graceful shutdown."""
		def signal_handler(signum, frame):
			print(f"\nReceived signal {signum}, shutting down gracefully...")
			GLib.idle_add(self.quit, None)

		# Handle Ctrl+C (SIGINT) and termination (SIGTERM)
		signal.signal(signal.SIGINT, signal_handler)
		signal.signal(signal.SIGTERM, signal_handler)

	def build_menu(self):
		"""Build the tray context menu from bookmarks and add control items."""
		# Clear existing menu items
		self.menu.foreach(lambda widget: self.menu.remove(widget))

		# Load bookmarks and create menu items
		bookmarks = load_bookmarks()
		for label, target in bookmarks:
			if label == '__GROUP__':
				# Create group header (disabled, bold text)
				item = Gtk.MenuItem(label=target)
				item.set_sensitive(False)
				item.get_child().set_markup(f'<b>{target}</b>')
				self.menu.append(item)
			else:
				# Create clickable bookmark item
				item = Gtk.MenuItem(label=label)
				item.connect('activate', self.on_bookmark_activate, target, label)
				self.menu.append(item)

		# Add separator and control menu items
		self.menu.append(Gtk.SeparatorMenuItem())

		edit_item = Gtk.MenuItem(label="Edit bookmarks/config")
		edit_item.connect('activate', self.on_edit_bookmarks)
		self.menu.append(edit_item)

		instr_item = Gtk.MenuItem(label="Show instructions")
		instr_item.connect('activate', self.on_show_instructions)
		self.menu.append(instr_item)

		self.menu.append(Gtk.SeparatorMenuItem())

		quit_item = Gtk.MenuItem(label="Quit")
		quit_item.connect('activate', self.quit)
		self.menu.append(quit_item)

		self.menu.show_all()

	def on_bookmark_activate(self, widget, target, label):
		"""Handle bookmark menu item click by opening SSH connection."""
		open_ssh_in_terminal(self.terminal, target, label)

	def on_edit_bookmarks(self, widget):
		"""Open the bookmark and configuration editor dialog."""
		def refresh_menu():
			"""Callback to refresh menu after changes."""
			self.terminal = read_config_terminal()
			self.build_menu()

		bookmarks = load_bookmarks()
		dialog = EditBookmarksDialog(None, bookmarks, self.terminal, on_change_callback=refresh_menu)
		dialog.run()
		dialog.destroy()

	def on_show_instructions(self, widget):
		"""Display help instructions dialog."""
		show_instructions()

	def quit(self, widget):
		"""Exit the application gracefully."""
		print("SSH Bookmark Manager shutting down...")
		try:
			# Give time for any pending operations to complete
			GLib.timeout_add(100, lambda: Gtk.main_quit() or False)
		except Exception as e:
			print(f"Error during shutdown: {e}")
			Gtk.main_quit()

def main():
	"""Main application entry point."""
	try:
		# Ensure configuration files exist, show help if first run
		created = ensure_config_files()

		# Create and run the tray application
		app = SSHTrayApp()

		# Show instructions on first run
		if created:
			show_instructions()

		print("SSH Bookmark Manager started. Press Ctrl+C to quit gracefully.")

		# Start GTK main loop
		Gtk.main()

	except KeyboardInterrupt:
		print("\nShutdown interrupted by user.")
	except Exception as e:
		print(f"Error starting SSH Bookmark Manager: {e}")
		sys.exit(1)
	finally:
		print("SSH Bookmark Manager stopped.")

if __name__ == '__main__':
	main()
</file>

<file path="src/ssh_tray/widgets.py">
"""
===============================================================================
ssh_tray.widgets.py - Reusable UI widgets for SSH Bookmark Manager editor
Author: Vanco Ordanoski
MIT License

UI widget classes for terminal selection, bookmark lists, and action buttons.
===============================================================================
"""

from gi.repository import Gtk
from .configuration import CONFIG_FILE
from .system import show_notification, available_terminals

class TerminalSelectorWidget:
	"""Widget for terminal emulator selection and configuration."""
	
	def __init__(self, terminal):
		"""Initialize terminal selector widget.
		
		Args:
			terminal: Current terminal setting
		"""
		self.terminal = terminal
		self._create_widget()
	
	def _create_widget(self):
		"""Create the terminal selector UI components."""
		self.container = Gtk.Box(spacing=6)
		
		# Terminal selection label
		term_label = Gtk.Label(label="Terminal:")
		self.container.pack_start(term_label, False, False, 0)
		
		# Dropdown for common available terminals
		self.term_combo = Gtk.ComboBoxText()
		available_terms = available_terminals()
		for terminal in available_terms:
			self.term_combo.append_text(terminal)
		
		# Set current selection if terminal is in the list
		if self.terminal in available_terms:
			self.term_combo.set_active(available_terms.index(self.terminal))
		else:
			self.term_combo.set_active(-1)  # No selection
		
		self.container.pack_start(self.term_combo, False, False, 0)
		
		# Text entry for custom terminal commands or editing
		self.term_entry = Gtk.Entry()
		self.term_entry.set_text(self.terminal)
		self.term_combo.connect("changed", self._on_combo_changed)
		self.container.pack_start(self.term_entry, True, True, 0)
		
		# Save terminal setting button
		save_icon = Gtk.Image.new_from_icon_name("document-save", Gtk.IconSize.BUTTON)
		self.save_btn = Gtk.Button()
		self.save_btn.set_image(save_icon)
		self.save_btn.set_tooltip_text("Save terminal setting")
		self.save_btn.connect("clicked", self._on_save_terminal)
		self.container.pack_start(self.save_btn, False, False, 0)
		
		# Help button for terminal information
		help_icon = Gtk.Image.new_from_icon_name("help-about", Gtk.IconSize.BUTTON)
		self.help_btn = Gtk.Button()
		self.help_btn.set_image(help_icon)
		self.help_btn.set_tooltip_text("Help: Supported terminals")
		self.container.pack_start(self.help_btn, False, False, 0)
	
	def _on_combo_changed(self, combo):
		"""Handle terminal dropdown selection change."""
		selected_text = combo.get_active_text()
		if selected_text:
			self.term_entry.set_text(selected_text)
	
	def _on_save_terminal(self, button):
		"""Save terminal setting to configuration file."""
		terminal = self.term_entry.get_text().strip()
		if not terminal:
			show_notification("Please enter a terminal command.", parent=None)
			return
		
		# Write terminal setting to config file
		try:
			with open(CONFIG_FILE, 'w') as config_file:
				config_file.write(f'terminal={terminal}\n')
			self.terminal = terminal
			show_notification(f"Terminal set to '{terminal}'.", parent=None)
		except Exception as e:
			show_notification(f"Failed to save terminal setting: {e}", parent=None)
	
	def get_widget(self):
		"""Get the GTK container widget.
		
		Returns:
			Gtk.Box: The terminal selector widget container
		"""
		return self.container
	
	def connect_help_handler(self, handler):
		"""Connect help button click handler.
		
		Args:
			handler: Function to call when help button is clicked
		"""
		self.help_btn.connect("clicked", handler)

class BookmarkListWidget:
	"""Widget for displaying and managing bookmark list with TreeView."""
	
	def __init__(self, bookmarks):
		"""Initialize bookmark list widget.
		
		Args:
			bookmarks: List of (label, target) bookmark tuples
		"""
		self.bookmarks = [list(item) for item in bookmarks]
		self._create_widget()
	
	def _create_widget(self):
		"""Create the bookmark list UI components."""
		# Create list store model for bookmarks data
		self.liststore = Gtk.ListStore(str, str)
		for label, target in self.bookmarks:
			self.liststore.append([label, target])
		
		# Create tree view with the list store model
		self.treeview = Gtk.TreeView(model=self.liststore)
		renderer_text = Gtk.CellRendererText()
		
		# Add columns for description and SSH target
		column_label = Gtk.TreeViewColumn("Description / Group", renderer_text, text=0)
		column_target = Gtk.TreeViewColumn("SSH Target", renderer_text, text=1)
		self.treeview.append_column(column_label)
		self.treeview.append_column(column_target)
		
		# Add scrolled window container for the list
		self.scrolled_window = Gtk.ScrolledWindow()
		self.scrolled_window.set_border_width(5)
		self.scrolled_window.set_vexpand(True)
		self.scrolled_window.add(self.treeview)
	
	def get_widget(self):
		"""Get the GTK scrolled window widget.
		
		Returns:
			Gtk.ScrolledWindow: The bookmark list widget container
		"""
		return self.scrolled_window
	
	def get_selection(self):
		"""Get the current TreeView selection.
		
		Returns:
			Gtk.TreeSelection: The tree view selection object
		"""
		return self.treeview.get_selection()
	
	def get_bookmarks(self):
		"""Get current bookmarks list from the tree view model.
		
		Returns:
			list: List of (label, target) tuples from the current model
		"""
		return [(row[0], row[1]) for row in self.liststore]
	
	def add_bookmark(self, label, target):
		"""Add a bookmark to the list.
		
		Args:
			label: Bookmark description or '__GROUP__' for groups
			target: SSH target string or group name
		"""
		self.liststore.append([label, target])
	
	def move_selection_up(self):
		"""Move selected item up in the list.
		
		Returns:
			bool: True if item was moved, False otherwise
		"""
		selection = self.treeview.get_selection()
		model, treeiter = selection.get_selected()
		if treeiter:
			path = model.get_path(treeiter)
			index = path.get_indices()[0]
			if index > 0:
				# Insert copy above current position, then remove original
				model.insert(index - 1, list(model[treeiter]))
				model.remove(treeiter)
				# Re-select the moved item
				iter_moved = model.get_iter(index - 1)
				self.treeview.get_selection().select_iter(iter_moved)
				return True
		return False
	
	def move_selection_down(self):
		"""Move selected item down in the list.
		
		Returns:
			bool: True if item was moved, False otherwise
		"""
		selection = self.treeview.get_selection()
		model, treeiter = selection.get_selected()
		if treeiter:
			path = model.get_path(treeiter)
			index = path.get_indices()[0]
			if index < len(model) - 1:
				# Insert copy below next position, then remove original
				model.insert(index + 2, list(model[treeiter]))
				model.remove(treeiter)
				# Re-select the moved item
				iter_moved = model.get_iter(index + 1)
				self.treeview.get_selection().select_iter(iter_moved)
				return True
		return False
	
	def delete_selection(self):
		"""Delete the selected item from the list.
		
		Returns:
			bool: True if item was deleted, False otherwise
		"""
		selection = self.treeview.get_selection()
		model, treeiter = selection.get_selected()
		if treeiter:
			model.remove(treeiter)
			return True
		return False

class ActionButtonsWidget:
	"""Widget containing action buttons for bookmark management operations."""
	
	def __init__(self):
		"""Initialize action buttons widget with all management buttons."""
		self._create_widget()
	
	def _create_widget(self):
		"""Create the action buttons UI components."""
		self.container = Gtk.Box(spacing=8)
		
		# Add bookmark button
		self.add_btn = Gtk.Button(label="Add")
		self.add_btn.set_image(Gtk.Image.new_from_icon_name("list-add", Gtk.IconSize.BUTTON))
		self.add_btn.set_always_show_image(True)
		self.add_btn.set_tooltip_text("Add new bookmark")
		
		# Edit selected bookmark button
		self.edit_btn = Gtk.Button(label="Edit")
		self.edit_btn.set_image(Gtk.Image.new_from_icon_name("document-edit", Gtk.IconSize.BUTTON))
		self.edit_btn.set_always_show_image(True)
		self.edit_btn.set_tooltip_text("Edit selected bookmark or group")
		
		# Delete selected bookmark button
		self.del_btn = Gtk.Button(label="Delete")
		self.del_btn.set_image(Gtk.Image.new_from_icon_name("edit-delete", Gtk.IconSize.BUTTON))
		self.del_btn.set_always_show_image(True)
		self.del_btn.set_tooltip_text("Delete selected bookmark or group")
		
		# Add group header button
		self.grp_btn = Gtk.Button(label="Add Group")
		self.grp_btn.set_image(Gtk.Image.new_from_icon_name("folder-new", Gtk.IconSize.BUTTON))
		self.grp_btn.set_always_show_image(True)
		self.grp_btn.set_tooltip_text("Add new group header")
		
		# Move item up in list button
		self.up_btn = Gtk.Button(label="Up")
		self.up_btn.set_image(Gtk.Image.new_from_icon_name("go-up", Gtk.IconSize.BUTTON))
		self.up_btn.set_always_show_image(True)
		self.up_btn.set_tooltip_text("Move selected item up")
		
		# Move item down in list button
		self.down_btn = Gtk.Button(label="Down")
		self.down_btn.set_image(Gtk.Image.new_from_icon_name("go-down", Gtk.IconSize.BUTTON))
		self.down_btn.set_always_show_image(True)
		self.down_btn.set_tooltip_text("Move selected item down")
		
		# Pack all buttons into the container
		for btn in [self.add_btn, self.edit_btn, self.del_btn, 
		           self.grp_btn, self.up_btn, self.down_btn]:
			self.container.pack_start(btn, False, False, 0)
	
	def get_widget(self):
		"""Get the GTK container widget.
		
		Returns:
			Gtk.Box: The action buttons widget container
		"""
		return self.container
	
	def connect_handlers(self, handlers):
		"""Connect button click handlers to their respective functions.
		
		Args:
			handlers: Dict with keys: add, edit, delete, group, up, down
		            Each value should be a callable function
		"""
		self.add_btn.connect("clicked", handlers.get('add'))
		self.edit_btn.connect("clicked", handlers.get('edit'))
		self.del_btn.connect("clicked", handlers.get('delete'))
		self.grp_btn.connect("clicked", handlers.get('group'))
		self.up_btn.connect("clicked", handlers.get('up'))
		self.down_btn.connect("clicked", handlers.get('down'))
</file>

<file path="web/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSH Bookmark Manager - Easy SSH Connection Management for Linux</title>
    <meta name="description" content="Manage your SSH connections through a convenient system tray application. Organize bookmarks, groups, and terminal preferences with one-click access.">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        header {
            padding: 2rem 0;
            text-align: center;
            color: white;
        }
        
        .logo {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 300;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 2rem;
        }
        
        .main-content {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            margin: 2rem 0;
            overflow: hidden;
        }
        
        .hero {
            padding: 3rem 2rem;
            text-align: center;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }
        
        .install-section {
            background: #2d3748;
            color: white;
            padding: 2rem;
            margin: 2rem 0;
            border-radius: 10px;
        }
        
        .install-command {
            background: #1a202c;
            border: 2px solid #4a5568;
            border-radius: 8px;
            padding: 1.5rem;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            margin: 1rem 0;
            position: relative;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }
        
        .install-command:hover {
            border-color: #667eea;
        }
        
        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #667eea;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }
        
        .copy-btn:hover {
            background: #5a67d8;
        }
        
        .copy-btn.copied {
            background: #38a169;
        }
        
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            padding: 3rem 2rem;
        }
        
        .feature {
            text-align: center;
            padding: 1.5rem;
        }
        
        .feature-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #667eea;
        }
        
        .feature h3 {
            margin-bottom: 1rem;
            color: #2d3748;
        }
        
        .requirements {
            background: #f8f9fa;
            padding: 2rem;
            margin: 2rem 0;
            border-left: 4px solid #667eea;
        }
        
        .requirements ul {
            list-style: none;
            padding-left: 0;
        }
        
        .requirements li {
            padding: 0.5rem 0;
            position: relative;
            padding-left: 2rem;
        }
        
        .requirements li::before {
            content: "✓";
            position: absolute;
            left: 0;
            color: #38a169;
            font-weight: bold;
        }
        
        .quick-start {
            padding: 2rem;
            background: #f0fff4;
            border-radius: 10px;
            margin: 2rem 0;
        }
        
        .step {
            display: flex;
            align-items: center;
            margin: 1rem 0;
        }
        
        .step-number {
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
            font-weight: bold;
        }
        
        .links {
            text-align: center;
            padding: 2rem;
            background: #f8f9fa;
        }
        
        .links a {
            display: inline-block;
            margin: 0.5rem 1rem;
            padding: 0.75rem 1.5rem;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: background 0.3s ease;
        }
        
        .links a:hover {
            background: #5a67d8;
        }
        
        .links a.secondary {
            background: #e2e8f0;
            color: #4a5568;
        }
        
        .links a.secondary:hover {
            background: #cbd5e0;
        }
        
        footer {
            text-align: center;
            padding: 2rem;
            color: white;
            opacity: 0.8;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .hero {
                padding: 2rem 1rem;
            }
            
            .install-command {
                font-size: 0.9rem;
                padding: 1rem;
            }
            
            .copy-btn {
                position: static;
                margin-top: 1rem;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">🖥️</div>
            <h1>SSH Bookmark Manager</h1>
            <p class="subtitle">Streamline your SSH connections with an elegant Linux tray application</p>
        </header>
        
        <div class="main-content">
            <div class="hero">
                <h2>One-Click SSH Access from Your System Tray</h2>
                <p>Organize your SSH connections into groups, launch them instantly, and manage everything through a clean, intuitive interface.</p>
            </div>
            
            <div class="install-section">
                <h3>🚀 Quick Install</h3>
                <p>Install SSH Bookmark Manager with a single command:</p>
                <div class="install-command" onclick="copyInstallCommand()">
                    <code>curl -fsSL https://raw.githubusercontent.com/vordan/ssh-tray/main/install.sh | bash</code>
                    <button class="copy-btn" id="copyBtn">Copy</button>
                </div>
                <p><small>This command downloads and installs the latest version automatically. Requires sudo access.</small></p>
            </div>
            
            <div class="features">
                <div class="feature">
                    <div class="feature-icon">⚡</div>
                    <h3>Instant Access</h3>
                    <p>Click any bookmark from the system tray to launch SSH connections immediately in your preferred terminal.</p>
                </div>
                
                <div class="feature">
                    <div class="feature-icon">📁</div>
                    <h3>Smart Organization</h3>
                    <p>Group your servers by environment, project, or any system that works for you. Visual separators keep everything organized.</p>
                </div>
                
                <div class="feature">
                    <div class="feature-icon">🔧</div>
                    <h3>Terminal Flexibility</h3>
                    <p>Works with mate-terminal, gnome-terminal, xfce4-terminal, tilix, konsole, and many others. Choose your favorite.</p>
                </div>
                
                <div class="feature">
                    <div class="feature-icon">🎛️</div>
                    <h3>Easy Management</h3>
                    <p>Add, edit, delete, and reorder bookmarks through a simple GUI editor, or edit the plain text configuration files directly.</p>
                </div>
                
                <div class="feature">
                    <div class="feature-icon">🖥️</div>
                    <h3>Desktop Integration</h3>
                    <p>Autostart on login, applications menu integration, and follows Linux desktop standards for a native experience.</p>
                </div>
                
                <div class="feature">
                    <div class="feature-icon">🔒</div>
                    <h3>Secure & Simple</h3>
                    <p>Uses your existing SSH configuration and keys. No passwords stored, no network access needed after installation.</p>
                </div>
            </div>
            
            <div class="requirements">
                <h3>📋 System Requirements</h3>
                <ul>
                    <li>Linux distribution (Ubuntu, Fedora, Debian, Mint, Arch, etc.)</li>
                    <li>Desktop environment with system tray support</li>
                    <li>Python 3.6+ with GTK3 bindings</li>
                    <li>Terminal emulator (mate-terminal, gnome-terminal, etc.)</li>
                    <li>sudo access for installation</li>
                </ul>
            </div>
            
            <div class="quick-start">
                <h3>🏃 Quick Start Guide</h3>
                
                <div class="step">
                    <div class="step-number">1</div>
                    <div>
                        <strong>Install dependencies:</strong><br>
                        <code>sudo apt install python3-gi gir1.2-appindicator3-0.1</code>
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">2</div>
                    <div>
                        <strong>Run the installer:</strong><br>
                        Use the one-line install command above
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">3</div>
                    <div>
                        <strong>Start the application:</strong><br>
                        <code>ssh-tray</code>
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">4</div>
                    <div>
                        <strong>Add your bookmarks:</strong><br>
                        Right-click the tray icon → "Edit bookmarks/config"
                    </div>
                </div>
            </div>
            
            <div class="links">
                <h3>📚 Documentation & Support</h3>
                <a href="https://github.com/vordan/ssh-tray">View on GitHub</a>
                <a href="https://github.com/vordan/ssh-tray/blob/main/README.md">User Guide</a>
                <a href="https://github.com/vordan/ssh-tray/blob/main/INSTALL.md">Installation Guide</a>
                <a href="https://github.com/vordan/ssh-tray/blob/main/MAKE.md" class="secondary">Developer Docs</a>
                <a href="https://github.com/vordan/ssh-tray/issues" class="secondary">Report Issues</a>
            </div>
        </div>
        
        <footer>
            <p>SSH Bookmark Manager v1.0.0</p>
            <p>Created by Vanco Ordanoski • Infoproject LLC, North Macedonia</p>
            <p>Open source under MIT License</p>
        </footer>
    </div>
    
    <script>
        function copyInstallCommand() {
            const command = 'curl -fsSL https://raw.githubusercontent.com/vordan/ssh-tray/main/install.sh | bash';
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(command).then(() => {
                    showCopySuccess();
                }).catch(() => {
                    fallbackCopy(command);
                });
            } else {
                fallbackCopy(command);
            }
        }
        
        function fallbackCopy(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showCopySuccess();
            } catch (err) {
                console.error('Failed to copy text: ', err);
                alert('Please copy the command manually');
            }
            
            document.body.removeChild(textArea);
        }
        
        function showCopySuccess() {
            const btn = document.getElementById('copyBtn');
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            btn.classList.add('copied');
            
            setTimeout(() => {
                btn.textContent = originalText;
                btn.classList.remove('copied');
            }, 2000);
        }
        
        // Add some interactive effects
        document.addEventListener('DOMContentLoaded', function() {
            // Smooth scroll for any anchor links
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    const target = document.querySelector(this.getAttribute('href'));
                    if (target) {
                        target.scrollIntoView({
                            behavior: 'smooth'
                        });
                    }
                });
            });
            
            // Add hover effects to feature cards
            document.querySelectorAll('.feature').forEach(feature => {
                feature.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-5px)';
                    this.style.transition = 'transform 0.3s ease';
                });
                
                feature.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0)';
                });
            });
        });
    </script>
</body>
</html>
</file>

<file path="INSTALL.md">
# Installation Guide

**Get SSH Bookmark Manager running in 2 minutes**

![Installation Process](docs/images/installation-demo.png)
*Simple one-command installation that sets up everything automatically*

---

## 🚀 Quick Install

```bash
curl -fsSL https://raw.githubusercontent.com/vordan/ssh-tray/main/install.sh | bash
```

**Then run:** `ssh-tray`

![First Run](docs/images/first-run.png)
*SSH Bookmark Manager shows helpful instructions on first startup*

---

## 📋 Requirements

**System:**
- Linux with desktop environment
- Python 3.6+ 
- System tray support

**Install dependencies:**
```bash
# Ubuntu/Debian/Mint
sudo apt install python3-gi gir1.2-appindicator3-0.1

# Fedora
sudo dnf install python3-gobject libappindicator-gtk3-devel

# Terminal (pick one)
sudo apt install mate-terminal gnome-terminal xfce4-terminal
```

---

## 🔧 Manual Install

**Download & run:**
```bash
wget https://raw.githubusercontent.com/vordan/ssh-tray/main/install.sh
chmod +x install.sh
./install.sh
```

**From source:**
```bash
git clone https://github.com/vordan/ssh-tray.git
cd ssh-tray
./install.sh
```

---

## ⚡ First Run

1. **Start:** `ssh-tray`
2. **Right-click tray icon** → "Edit bookmarks/config" 
3. **Add your SSH servers**
4. **Click to connect!**

![Quick Setup](docs/images/quick-setup.png)
*Add your first bookmark in seconds with the intuitive editor*

---

## 🗑️ Uninstall

**Remove everything:**
```bash
ssh-tray --uninstall
```

*Offers to backup your bookmarks*

![Uninstall Process](docs/images/uninstall-backup.png)
*Safe uninstall process with automatic configuration backup*

---

## 🆘 Troubleshooting

**"AppIndicator3 not found"**
```bash
sudo apt install gir1.2-appindicator3-0.1
```

**"No tray icon"**
- Check desktop supports system tray
- Try different desktop environment

**"Terminal not found"**
- Install a terminal: `sudo apt install mate-terminal`
- Configure in settings

**Need help?**
- 📧 vordan@infoproject.biz
- 🐛 [GitHub Issues](https://github.com/vordan/ssh-tray/issues)

---

**Installation takes ~30 seconds • Works on Ubuntu, Mint, Fedora, and more**
</file>

<file path="install.sh">
#!/bin/bash
# install.sh - SSH Bookmark Manager Installer (no git required)

set -e

cat <<EOF
===============================================================================
SSH Bookmark Manager Installer
-----------------------------
This script will:
 - Download the latest version of SSH Bookmark Manager from GitHub as a ZIP.
 - Install the project into /opt/ssh-tray (requires sudo).
 - Generate a unique user ID for sync functionality.
 - Make all scripts executable.
 - Create a launcher script for easy startup.
 - Create a symlink in /usr/local/bin so you can launch 'ssh-tray' from anywhere.
 - No changes to user files or home directory.
 - This script follows Linux FHS (Filesystem Hierarchy Standard).

If you already have /opt/ssh-tray, it will be replaced (after confirmation).

Are you sure you want to CONTINUE? [Y/n]
EOF

read -r ok
case "$ok" in [nN]*) echo "Aborted."; exit 1;; esac

# Configuration
REPO_URL="https://github.com/vordan/ssh-tray"
ZIP_URL="https://github.com/vordan/ssh-tray/archive/refs/heads/main.zip"
INSTALL_DIR="/opt/ssh-tray"
BIN_NAME="ssh-tray"
MAIN_LAUNCHER="src/ssh_tray.py"
STARTER_SH="ssh-tray-start.sh"

echo
echo "This installer requires sudo privileges to install to /opt and create symlinks."
echo

# Check if we can sudo
if ! sudo -v; then
	echo "Error: sudo access required for installation to /opt"
	exit 1
fi

# Create temporary directory for download
TMP_DIR=$(mktemp -d)

echo "Downloading the latest code from $REPO_URL ..."
wget -qO "$TMP_DIR/main.zip" "$ZIP_URL"
unzip -q "$TMP_DIR/main.zip" -d "$TMP_DIR"
REPO_SUBDIR="$TMP_DIR/ssh-tray-main"

# Check if install directory exists
if [ -d "$INSTALL_DIR" ]; then
	echo "WARNING: Install directory $INSTALL_DIR exists. It will be overwritten."
	read -p "Continue and overwrite [$INSTALL_DIR]? [Y/n] " ok
	case "$ok" in [nN]*) echo "Aborted."; exit 1;; esac
	sudo rm -rf "$INSTALL_DIR"
fi

# Install to /opt with proper permissions
echo "Installing to $INSTALL_DIR ..."
sudo mv "$REPO_SUBDIR" "$INSTALL_DIR"
sudo chown -R root:root "$INSTALL_DIR"

# Generate unique user ID for sync functionality
echo "Generating unique user ID for sync functionality..."
if command -v openssl >/dev/null 2>&1; then
	USER_ID=$(openssl rand -hex 8)
elif command -v xxd >/dev/null 2>&1 && [ -r /dev/urandom ]; then
	USER_ID=$(head -c 8 /dev/urandom | xxd -p)
else
	# Fallback method using date and hostname
	USER_ID=$(echo "${HOSTNAME}$(date +%s)" | sha256sum | cut -c1-16)
fi

echo "Creating user ID file..."
sudo tee "$INSTALL_DIR/.user_id" > /dev/null <<EOF2
user_id=$USER_ID
created=$(date -Iseconds)
hostname=$(hostname)
EOF2
sudo chmod 644 "$INSTALL_DIR/.user_id"
echo "Generated sync user ID: $USER_ID"

# Make Python scripts executable
sudo chmod +x "$INSTALL_DIR/$MAIN_LAUNCHER"
sudo find "$INSTALL_DIR/src" -name "*.py" -exec sudo chmod +x {} \;
sudo find "$INSTALL_DIR/scripts" -name "*.sh" -exec sudo chmod +x {} \;

# Copy and setup uninstaller
echo "Setting up uninstaller..."
sudo cp "$INSTALL_DIR/scripts/uninstall.sh" "$INSTALL_DIR/"
sudo chmod +x "$INSTALL_DIR/uninstall.sh"

# Create uninstaller symlink
UNINSTALL_SYMLINK="/usr/local/bin/ssh-tray-uninstall"
sudo ln -sf "$INSTALL_DIR/uninstall.sh" "$UNINSTALL_SYMLINK"
echo "Created uninstaller symlink $UNINSTALL_SYMLINK -> $INSTALL_DIR/uninstall.sh"

# Create the starter script
sudo tee "$INSTALL_DIR/$STARTER_SH" > /dev/null <<EOF2
#!/bin/bash
# SSH Bookmark Manager launcher script
cd "$INSTALL_DIR"
exec python3 "$MAIN_LAUNCHER" "\$@"
EOF2
sudo chmod +x "$INSTALL_DIR/$STARTER_SH"

# Create symlink in /usr/local/bin
LINK_TARGET="/usr/local/bin/$BIN_NAME"
sudo ln -sf "$INSTALL_DIR/$STARTER_SH" "$LINK_TARGET"
echo "Created symlink $LINK_TARGET -> $INSTALL_DIR/$STARTER_SH"

echo
echo "Installation complete!"
echo
echo "You can now start SSH Bookmark Manager with:"
echo "    $BIN_NAME"
echo
echo "Available commands:"
echo "    $BIN_NAME                Start the tray application"
echo "    $BIN_NAME --help         Show help and usage information"
echo "    $BIN_NAME --version      Show version information"
echo "    $BIN_NAME --uninstall    Uninstall the application"
echo "    ssh-tray-uninstall       Direct uninstaller access"
echo
echo "Sync functionality:"
echo "    User ID: $USER_ID"
echo "    Configure sync server in the application settings"
echo
echo "The application will create configuration files in your home directory:"
echo "    ~/.ssh-bookmarks     (your SSH bookmarks)"
echo "    ~/.ssh-tray-config   (terminal and sync preferences)"
echo
echo "To edit bookmarks/config, use the tray menu when the app is running."
echo
echo "To uninstall, you can use any of these methods:"
echo "    $BIN_NAME --uninstall"
echo "    ssh-tray-uninstall"
echo "    $INSTALL_DIR/uninstall.sh"
echo
echo "See README.md at $INSTALL_DIR for more information."

# Cleanup
rm -rf "$TMP_DIR"
</file>

<file path="LICENSE.md">
MIT License

Copyright (c) 2025 Vanco Ordanoski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
</file>

<file path="repomix.config.json">
{
	"input": {
		"maxFileSize": 52428800
	},
	"output": {
		"filePath": "ssh-tray-repomix-output.xml",
		"style": "xml",
		"parsableStyle": false,
		"fileSummary": true,
		"directoryStructure": true,
		"files": true,
		"removeComments": false,
		"removeEmptyLines": false,
		"compress": false,
		"topFilesLength": 5,
		"showLineNumbers": false,
		"copyToClipboard": false,
		"git": {
			"sortByChanges": true,
			"sortByChangesMaxCommits": 100
		}
	},
	"include": [],
	"ignore": {
		"useGitignore": true,
		"useDefaultPatterns": true,
		"customPatterns": ["src/lib/vendor/*"]
	},
	"security": {
		"enableSecurityCheck": true
	},
	"tokenCount": {
		"encoding": "o200k_base"
	}
}
</file>

<file path="src/ssh_tray/configuration.py">
"""
===============================================================================
ssh_tray.configuration.py - Configuration & bookmarks management for SSH Tray
Author: Vanco Ordanoski
MIT License

Handles reading/writing config, bookmarks, validation, help text.
===============================================================================
"""

import os
import shutil
from .system import show_notification, available_terminals

BOOKMARKS_FILE = os.path.expanduser('~/.ssh-bookmarks')
CONFIG_FILE = os.path.expanduser('~/.ssh-tray-config')

def ensure_config_files():
	"""Create default configuration files if they don't exist.

	Returns:
		bool: True if files were created (first run), False if they existed
	"""
	created = False

	# Create default terminal configuration
	if not os.path.exists(CONFIG_FILE):
		with open(CONFIG_FILE, 'w') as f:
			f.write('terminal=mate-terminal\n')
		created = True

	# Create example bookmarks file
	if not os.path.exists(BOOKMARKS_FILE):
		with open(BOOKMARKS_FILE, 'w') as f:
			f.write('# Example SSH bookmarks:\n')
			f.write('------ Dev Servers ------\n')
			f.write('Dev 1 [10.10.10.98]\troot@10.10.10.98\n')
			f.write('Dev 2 [10.10.11.22]\troot@10.10.11.22\n')
			f.write('------ Production ------\n')
			f.write('Prod DB\tadmin@192.168.1.5\n')
		created = True

	return created

def show_instructions(parent=None):
	"""Display help dialog with usage instructions and file locations."""
	from gi.repository import Gtk

	text = (
		"SSH Bookmark Manager Help\n\n"
		"Bookmarks: {}\n"
		"Config: {}\n\n"
		"How to use:\n"
		" - Each line in the bookmarks file is either:\n"
		"     * a bookmark: DESCRIPTION<tab>user@host[:port]\n"
		"     * a group header: a line with dashes, e.g. '------ Group Name ------'\n"
		" - Set your terminal in the config file (e.g. 'terminal=mate-terminal').\n"
		" - Edit everything using the tray editor, or a text editor if you prefer.\n"
		" - Use the tray icon to launch SSH, edit bookmarks, show help, or configure autostart.\n"
		" - For menu or autostart integration, see configuration in the tray menu."
	).format(BOOKMARKS_FILE, CONFIG_FILE)

	dialog = Gtk.MessageDialog(
		parent=parent, modal=True, message_type=Gtk.MessageType.INFO,
		buttons=Gtk.ButtonsType.OK, text="SSH Bookmark Manager - Instructions")
	dialog.format_secondary_text(text)
	dialog.set_border_width(20)
	dialog.connect("response", lambda d, r: d.destroy())
	dialog.connect("delete-event", lambda d, e: d.destroy() or False)
	dialog.show_all()
	dialog.run()
	dialog.destroy()

def read_config_terminal():
	"""Read terminal emulator setting from configuration file.

	Returns:
		str: Terminal command name or path, defaults to available terminal if configured one is missing
	"""
	terminal = 'mate-terminal'

	# Read terminal setting from config file
	if os.path.exists(CONFIG_FILE):
		with open(CONFIG_FILE) as f:
			for line in f:
				line = line.strip()
				if line.startswith('terminal='):
					val = line.split('=', 1)[1].strip()
					if val:
						terminal = val
					break

	# Validate terminal exists and is executable
	if not (os.path.isabs(terminal) and os.access(terminal, os.X_OK)) and shutil.which(terminal) is None:
		show_notification(f"Terminal '{terminal}' not found in PATH.\nPlease select or set a valid terminal in the configuration.")
		avail = available_terminals()
		if avail:
			terminal = avail[0]
		else:
			terminal = 'xterm'

	return terminal

def validate_bookmark_line(line):
	"""Parse and validate a single bookmark file line.

	Args:
		line (str): Line from bookmarks file

	Returns:
		tuple or None: (label, target) for bookmarks, ('__GROUP__', name) for groups, None for invalid/comments
	"""
	line = line.strip()

	# Skip empty lines and comments
	if not line or line.startswith('#'):
		return None

	# Check for group header (lines with dashes)
	if line.startswith('-') and line.endswith('-') and len(line) > 3:
		return ('__GROUP__', line.strip('- ').strip())

	# Parse bookmark line (description and SSH target separated by whitespace)
	parts = line.rsplit(None, 1)
	if len(parts) == 2:
		label, ssh_target = parts
		# Validate SSH target contains username@host
		# Enhanced validation
		if '@' in ssh_target:
			# Validate SSH target format: user@host[:port]
			import re
			pattern = r'^[a-zA-Z0-9\-._]+@[a-zA-Z0-9\-._]+(?::\d{1,5})?$'
			if re.match(pattern, ssh_target):
				# Validate port range if specified
				if ':' in ssh_target:
					try:
						port = int(ssh_target.split(':')[-1])
						if not (1 <= port <= 65535):
							return None
					except ValueError:
						return None
				return (label, ssh_target)
	return None

def load_bookmarks():
	"""Load and validate bookmarks from the bookmarks file.

	Returns:
		list: List of (label, target) tuples for valid bookmarks and groups
	"""
	bookmarks = []
	errors = []

	if os.path.exists(BOOKMARKS_FILE):
		with open(BOOKMARKS_FILE, 'r') as f:
			for idx, line in enumerate(f):
				result = validate_bookmark_line(line)
				if result:
					bookmarks.append(result)
				elif line.strip() and not line.strip().startswith('#'):
					# Track invalid non-comment lines
					errors.append(f"Line {idx+1}: '{line.strip()}'")

	# Show validation errors if any
	if errors:
		show_notification("Invalid lines in bookmarks file:\n" + "\n".join(errors))

	return bookmarks

def save_bookmarks(bookmarks):
	"""Save bookmarks list to the bookmarks file.

	Args:
		bookmarks (list): List of (label, target) tuples to save
	"""
	with open(BOOKMARKS_FILE, 'w') as f:
		for label, ssh_target in bookmarks:
			if label == '__GROUP__':
				# Write group header with dashes
				f.write(f"------ {ssh_target} ------\n")
			else:
				# Write bookmark with tab separator
				f.write(f"{label}\t{ssh_target}\n")
</file>

<file path="src/ssh_tray/editor.py">
"""
===============================================================================
ssh_tray.editor.py - Main editor dialog coordinator for SSH Bookmark Manager
Author: Vanco Ordanoski
MIT License

Refactored main dialog that coordinates all editor components and handles interactions.
===============================================================================
"""

import os
from gi.repository import Gtk
from .configuration import load_bookmarks, save_bookmarks, read_config_terminal
from .system import is_autostart_enabled, add_to_autostart, create_desktop_file, show_notification
from .dialogs import BookmarkDialog, GroupDialog, show_terminal_help
from .widgets import BookmarkListWidget, TerminalSelectorWidget, ActionButtonsWidget
from .sync import get_sync_config, save_sync_config, is_sync_enabled, upload_bookmarks, download_bookmarks, test_sync_connection

class EditBookmarksDialog(Gtk.Dialog):
	"""Main editor dialog for bookmarks, configuration, and system integration."""
	
	def __init__(self, parent, bookmarks, terminal, on_change_callback):
		"""Initialize the editor dialog with current bookmarks and settings.
		
		Args:
			parent: Parent window for modal dialog
			bookmarks: Current list of bookmarks
			terminal: Current terminal setting
			on_change_callback: Function to call when changes are made
		"""
		Gtk.Dialog.__init__(self, title="Edit SSH Bookmarks and Configuration", 
		                   transient_for=parent, modal=True)
		self.set_border_width(20)
		self.set_default_size(650, 500)
		
		# Store current state and callback
		self.terminal = terminal
		self.on_change_callback = on_change_callback
		
		# Initialize the complete dialog layout
		self._setup_layout(bookmarks)
		self.show_all()
	
	def _setup_layout(self, bookmarks):
		"""Set up the main dialog layout with all components."""
		box = self.get_content_area()
		
		# Add descriptive subtitle explaining dialog purpose
		subtitle = Gtk.Label()
		subtitle.set_text(
			"Here you can add, remove, group, and reorder SSH bookmarks, "
			"and configure your terminal and autostart options.")
		subtitle.set_justify(Gtk.Justification.LEFT)
		subtitle.set_halign(Gtk.Align.START)
		subtitle.set_margin_top(20)
		subtitle.set_margin_bottom(20)
		box.pack_start(subtitle, False, False, 0)
		
		# Terminal configuration section
		self.terminal_widget = TerminalSelectorWidget(self.terminal)
		self.terminal_widget.connect_help_handler(self._on_help_terminal)
		box.pack_start(self.terminal_widget.get_widget(), False, False, 10)
		
		# Bookmark list management section
		self.bookmark_widget = BookmarkListWidget(bookmarks)
		box.pack_start(self.bookmark_widget.get_widget(), True, True, 10)
		
		# Action buttons for bookmark operations
		self.action_widget = ActionButtonsWidget()
		self.action_widget.connect_handlers({
			'add': self._on_add,
			'edit': self._on_edit,
			'delete': self._on_delete,
			'group': self._on_add_group,
			'up': self._on_move_up,
			'down': self._on_move_down
		})
		box.pack_start(self.action_widget.get_widget(), False, False, 10)
		
		# System integration options section
		self._create_system_options(box)
	
	def _create_system_options(self, box):
		"""Create system integration options (autostart, desktop file, and sync)."""
		opt_box = Gtk.Box(spacing=8)
		
		# Autostart toggle switch for login startup
		self.autostart_switch = Gtk.Switch()
		self.autostart_switch.set_active(is_autostart_enabled())
		self.autostart_switch.connect("notify::active", self._on_autostart_toggle)
		opt_box.pack_start(Gtk.Label(label="Autostart:"), False, False, 0)
		opt_box.pack_start(self.autostart_switch, False, False, 0)
		
		# Add separator between autostart and other options
		separator1 = Gtk.Separator(orientation=Gtk.Orientation.VERTICAL)
		opt_box.pack_start(separator1, False, False, 8)
		
		# Sync toggle switch for configuration synchronization
		self.sync_switch = Gtk.Switch()
		self.sync_switch.set_active(is_sync_enabled())
		self.sync_switch.connect("notify::active", self._on_sync_toggle)
		opt_box.pack_start(Gtk.Label(label="Sync:"), False, False, 0)
		opt_box.pack_start(self.sync_switch, False, False, 0)
		
		# Sync configuration button
		sync_config_btn = Gtk.Button(label="Sync Settings")
		sync_config_btn.set_image(Gtk.Image.new_from_icon_name("preferences-system", Gtk.IconSize.BUTTON))
		sync_config_btn.set_always_show_image(True)
		sync_config_btn.set_tooltip_text("Configure sync server and options")
		sync_config_btn.connect("clicked", self._on_sync_config)
		opt_box.pack_start(sync_config_btn, False, False, 0)
		
		# Add separator between sync and menu button
		separator2 = Gtk.Separator(orientation=Gtk.Orientation.VERTICAL)
		opt_box.pack_start(separator2, False, False, 8)
		
		# Add to applications menu button with icon and text
		desktop_btn = Gtk.Button(label="Add to Menu")
		desktop_btn.set_image(Gtk.Image.new_from_icon_name("applications-internet", Gtk.IconSize.BUTTON))
		desktop_btn.set_always_show_image(True)
		desktop_btn.set_tooltip_text("Add SSH Bookmark Manager to applications menu")
		desktop_btn.connect("clicked", self._on_add_to_menu)
		opt_box.pack_start(desktop_btn, False, False, 0)
		
		box.pack_start(opt_box, False, False, 8)
	
	def _save_and_refresh(self):
		"""Save current bookmarks to file and trigger menu refresh."""
		bookmarks = self.bookmark_widget.get_bookmarks()
		save_bookmarks(bookmarks)
		if self.on_change_callback:
			self.on_change_callback()
		return bookmarks
	
	# Event handlers for terminal help
	def _on_help_terminal(self, button):
		"""Display help information about supported terminals."""
		show_terminal_help(parent=self)
	
	# Event handlers for bookmark operations
	def _on_add(self, button):
		"""Show dialog to add a new bookmark."""
		dialog = BookmarkDialog(self, "Add Bookmark")
		response, label, target = dialog.run()
		if response == Gtk.ResponseType.OK:
			self.bookmark_widget.add_bookmark(label, target)
			self._save_and_refresh()
		dialog.destroy()
	
	def _on_edit(self, button):
		"""Show dialog to edit the selected bookmark or group."""
		selection = self.bookmark_widget.get_selection()
		model, treeiter = selection.get_selected()
		if not treeiter:
			return  # Nothing selected
		
		label_old = model[treeiter][0]
		target_old = model[treeiter][1]
		
		if label_old == '__GROUP__':
			# Edit group name
			dialog = GroupDialog(self, "Edit Group", target_old)
			response, group_name = dialog.run()
			if response == Gtk.ResponseType.OK:
				model[treeiter][1] = group_name
				self._save_and_refresh()
			dialog.destroy()
		else:
			# Edit bookmark details
			dialog = BookmarkDialog(self, "Edit Bookmark", label_old, target_old)
			response, label, target = dialog.run()
			if response == Gtk.ResponseType.OK:
				model[treeiter][0] = label
				model[treeiter][1] = target
				self._save_and_refresh()
			dialog.destroy()
	
	def _on_delete(self, button):
		"""Delete the selected bookmark or group."""
		if self.bookmark_widget.delete_selection():
			self._save_and_refresh()
	
	def _on_add_group(self, button):
		"""Show dialog to add a new group header."""
		dialog = GroupDialog(self, "Add Group")
		response, group_name = dialog.run()
		if response == Gtk.ResponseType.OK:
			self.bookmark_widget.add_bookmark('__GROUP__', group_name)
			self._save_and_refresh()
		dialog.destroy()
	
	def _on_move_up(self, button):
		"""Move selected item up in the list."""
		if self.bookmark_widget.move_selection_up():
			self._save_and_refresh()
	
	def _on_move_down(self, button):
		"""Move selected item down in the list."""
		if self.bookmark_widget.move_selection_down():
			self._save_and_refresh()
	
	# Event handlers for system integration
	def _on_add_to_menu(self, button):
		"""Create desktop file and add application to system menu."""
		# Find the main launcher script path dynamically
		import sys
		
		# Try common installation paths first
		possible_paths = [
			'/opt/ssh-tray/src/ssh_tray.py',
			'/usr/local/bin/ssh-tray',
			os.path.join(os.path.dirname(sys.executable), 'ssh-tray'),
		]
		
		exec_path = None
		for path in possible_paths:
			if os.path.exists(path):
				exec_path = path
				break
		
		# Fallback to current module location if not found in standard paths
		if not exec_path:
			current_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
			exec_path = os.path.join(current_dir, 'ssh_tray.py')
		
		# Create the desktop file and notify user
		create_desktop_file(exec_path)
		show_notification("Added SSH Bookmark Manager to applications menu.", parent=self)
	
	def _on_autostart_toggle(self, switch, gparam):
		"""Handle autostart toggle switch changes."""
		if switch.get_active():
			add_to_autostart(True)
			show_notification("Autostart enabled - SSH Tray will start on login.", parent=self)
		else:
			add_to_autostart(False)
			show_notification("Autostart disabled.", parent=self)
	
	def _on_sync_toggle(self, switch, gparam):
		"""Handle sync toggle switch changes."""
		config = get_sync_config()
		if switch.get_active():
			if not config['user_id']:
				show_notification("Sync requires installation with user ID. Please reinstall or contact support.", parent=self)
				switch.set_active(False)
				return
			save_sync_config(True, config['server'], config['port'])
			show_notification("Sync enabled. Use 'Sync Settings' to configure server.", parent=self)
		else:
			save_sync_config(False, config['server'], config['port'])
			show_notification("Sync disabled.", parent=self)
	
	def _on_sync_config(self, button):
		"""Show sync configuration dialog."""
		self._show_sync_config_dialog()
	
	def _show_sync_config_dialog(self):
		"""Display sync configuration dialog with upload/download options."""
		config = get_sync_config()
		
		dialog = Gtk.Dialog(
			title="Sync Configuration", transient_for=self, modal=True)
		dialog.set_border_width(20)
		dialog.set_default_size(450, 350)
		
		# Add Close button
		dialog.add_button("Close", Gtk.ResponseType.CLOSE)
		
		box = dialog.get_content_area()
		
		# Server configuration section
		server_frame = Gtk.Frame(label="Server Settings")
		server_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
		server_box.set_border_width(10)
		
		# Server entry
		server_box.pack_start(Gtk.Label(label="Server:", halign=Gtk.Align.START), False, False, 0)
		server_entry = Gtk.Entry()
		server_entry.set_text(config['server'])
		server_box.pack_start(server_entry, False, False, 0)
		
		# Port entry
		server_box.pack_start(Gtk.Label(label="Port:", halign=Gtk.Align.START), False, False, 0)
		port_entry = Gtk.Entry()
		port_entry.set_text(str(config['port']))
		server_box.pack_start(port_entry, False, False, 0)
		
		# Save server settings button
		save_btn = Gtk.Button(label="Save Settings")
		save_btn.connect("clicked", lambda btn: self._save_server_settings(server_entry.get_text(), port_entry.get_text()))
		server_box.pack_start(save_btn, False, False, 0)
		
		# Test connection button
		test_btn = Gtk.Button(label="Test Connection")
		test_btn.connect("clicked", lambda btn: self._test_sync_connection())
		server_box.pack_start(test_btn, False, False, 0)
		
		server_frame.add(server_box)
		box.pack_start(server_frame, False, False, 10)
		
		# Sync operations section
		sync_frame = Gtk.Frame(label="Sync Operations")
		sync_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
		sync_box.set_border_width(10)
		
		# User ID display with copy button
		user_id_box = Gtk.Box(spacing=6)
		user_id_label = Gtk.Label(label="User ID:", halign=Gtk.Align.START)
		user_id_box.pack_start(user_id_label, False, False, 0)
		
		user_id_entry = Gtk.Entry()
		if config['user_id']:
			user_id_entry.set_text(config['user_id'])
			user_id_entry.set_editable(False)
		else:
			user_id_entry.set_text("Not configured")
			user_id_entry.set_editable(False)
		user_id_box.pack_start(user_id_entry, True, True, 0)
		
		# Copy User ID button
		copy_user_btn = Gtk.Button()
		copy_user_btn.set_image(Gtk.Image.new_from_icon_name("edit-copy", Gtk.IconSize.BUTTON))
		copy_user_btn.set_tooltip_text("Copy User ID to clipboard")
		copy_user_btn.connect("clicked", lambda btn: self._copy_to_clipboard(config['user_id'] or "", "User ID copied to clipboard!"))
		user_id_box.pack_start(copy_user_btn, False, False, 0)
		
		sync_box.pack_start(user_id_box, False, False, 0)
		
		# Upload button
		upload_btn = Gtk.Button(label="Upload Bookmarks")
		upload_btn.set_image(Gtk.Image.new_from_icon_name("go-up", Gtk.IconSize.BUTTON))
		upload_btn.set_always_show_image(True)
		upload_btn.connect("clicked", lambda btn: self._upload_bookmarks_with_display(dialog))
		sync_box.pack_start(upload_btn, False, False, 0)
		
		# Download section with User ID pre-filled
		download_label = Gtk.Label(label="Download from another computer:", halign=Gtk.Align.START)
		sync_box.pack_start(download_label, False, False, 0)
		
		download_box = Gtk.Box(spacing=6)
		download_entry = Gtk.Entry()
		download_entry.set_placeholder_text("Enter Sync ID (8 characters)")
		download_btn = Gtk.Button(label="Download")
		download_btn.set_image(Gtk.Image.new_from_icon_name("go-down", Gtk.IconSize.BUTTON))
		download_btn.set_always_show_image(True)
		download_btn.connect("clicked", lambda btn: self._download_bookmarks(download_entry.get_text().strip()))
		
		download_box.pack_start(download_entry, True, True, 0)
		download_box.pack_start(download_btn, False, False, 0)
		sync_box.pack_start(download_box, False, False, 0)
		
		sync_frame.add(sync_box)
		box.pack_start(sync_frame, True, True, 10)
		
		dialog.show_all()
		dialog.run()
		dialog.destroy()
	
	def _save_server_settings(self, server, port_str):
		"""Save sync server settings."""
		try:
			port = int(port_str)
			if not (1 <= port <= 65535):
				raise ValueError("Port must be between 1 and 65535")
			
			config = get_sync_config()
			save_sync_config(config['enabled'], server.strip(), port)
			show_notification("Server settings saved successfully.", parent=self)
		except ValueError as e:
			show_notification(f"Invalid port number: {e}", parent=self)
	
	def _test_sync_connection(self):
		"""Test connection to sync server."""
		if test_sync_connection():
			show_notification("✓ Connection successful!", parent=self)
		else:
			show_notification("✗ Connection failed. Check server settings.", parent=self)
	
	def _upload_bookmarks(self):
		"""Upload current bookmarks to sync server."""
		sync_id = upload_bookmarks()
		if sync_id:
			# Also refresh the menu since we just confirmed sync works
			self._save_and_refresh()
	
	def _upload_bookmarks_with_display(self, parent_dialog):
		"""Upload bookmarks and show sync ID in a copyable dialog."""
		sync_id = upload_bookmarks()
		if sync_id:
			# Show sync ID in a dialog with copy functionality
			self._show_sync_id_dialog(sync_id, parent_dialog)
			# Also refresh the menu since we just confirmed sync works
			self._save_and_refresh()
	
	def _show_sync_id_dialog(self, sync_id, parent):
		"""Show sync ID in a copyable dialog."""
		dialog = Gtk.Dialog(
			title="Upload Successful", transient_for=parent, modal=True)
		dialog.set_border_width(20)
		dialog.add_button("Close", Gtk.ResponseType.CLOSE)
		
		box = dialog.get_content_area()
		
		# Success message
		success_label = Gtk.Label()
		success_label.set_markup("<b>✓ Bookmarks uploaded successfully!</b>")
		box.pack_start(success_label, False, False, 10)
		
		# Instructions
		instr_label = Gtk.Label()
		instr_label.set_markup(
			"Share this Sync ID with your other computers to download these bookmarks:")
		instr_label.set_line_wrap(True)
		box.pack_start(instr_label, False, False, 5)
		
		# Sync ID display with copy button
		sync_id_box = Gtk.Box(spacing=6)
		sync_id_entry = Gtk.Entry()
		sync_id_entry.set_text(sync_id)
		sync_id_entry.set_editable(False)
		sync_id_entry.select_region(0, -1)  # Select all text for easy copying
		sync_id_box.pack_start(sync_id_entry, True, True, 0)
		
		# Copy Sync ID button
		copy_sync_btn = Gtk.Button(label="Copy")
		copy_sync_btn.set_image(Gtk.Image.new_from_icon_name("edit-copy", Gtk.IconSize.BUTTON))
		copy_sync_btn.set_always_show_image(True)
		copy_sync_btn.connect("clicked", lambda btn: self._copy_to_clipboard(sync_id, "Sync ID copied to clipboard!"))
		sync_id_box.pack_start(copy_sync_btn, False, False, 0)
		
		box.pack_start(sync_id_box, False, False, 10)
		
		# Usage instructions
		usage_label = Gtk.Label()
		usage_label.set_markup(
			"<i>On other computers:</i>\n"
			"1. Open SSH Bookmark Manager\n"
			"2. Go to Edit → Sync Settings\n"
			"3. Paste this Sync ID in the Download field")
		usage_label.set_justify(Gtk.Justification.LEFT)
		usage_label.set_halign(Gtk.Align.START)
		box.pack_start(usage_label, False, False, 10)
		
		dialog.show_all()
		dialog.run()
		dialog.destroy()
	
	def _copy_to_clipboard(self, text, success_message):
		"""Copy text to clipboard and show notification."""
		try:
			from gi.repository import Gdk
			clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)
			clipboard.set_text(text, -1)
			clipboard.store()
			show_notification(success_message, parent=self)
		except Exception as e:
			show_notification(f"Failed to copy to clipboard: {e}", parent=self)
	
	def _download_bookmarks(self, sync_id):
		"""Download bookmarks from sync server."""
		if not sync_id:
			show_notification("Please enter a sync ID.", parent=self)
			return
		
		if download_bookmarks(sync_id):
			# Refresh the bookmark list and menu
			bookmarks = load_bookmarks()
			self.bookmark_widget = BookmarkListWidget(bookmarks)
			# Find the scrolled window and replace its child
			for child in self.get_content_area().get_children():
				if isinstance(child, Gtk.ScrolledWindow):
					child.get_parent().remove(child)
					break
			
			# Re-add the updated bookmark widget
			box = self.get_content_area()
			children = box.get_children()
			# Insert after terminal widget and before action buttons
			box.pack_start(self.bookmark_widget.get_widget(), True, True, 10)
			box.reorder_child(self.bookmark_widget.get_widget(), 2)
			box.show_all()
			
			self._save_and_refresh()
</file>

<file path="src/ssh_tray/system.py">
"""
===============================================================================
ssh_tray.system.py - System integration (autostart, desktop file, terminals)
Author: Vanco Ordanoski
MIT License

Handles launching terminals, autostart, desktop integration, notifications, etc.
===============================================================================
"""

import os
import shutil
import subprocess
import shlex
import re

ICON_NAME = 'network-server'

def available_terminals():
	"""Get list of supported terminal emulators available on the system.
	
	Returns:
		list: Terminal command names that are found in PATH
	"""
	terminals = [
		'mate-terminal', 'gnome-terminal', 'xfce4-terminal', 'tilix',
		'konsole', 'lxterminal', 'xterm'
	]
	return [t for t in terminals if shutil.which(t)]

def show_notification(message, parent=None):
	"""Display a notification dialog with the given message.
	
	Args:
		message (str): Text to display in the dialog
		parent: Parent window for modal dialog (optional)
	"""
	from gi.repository import Gtk
	
	dialog = Gtk.MessageDialog(
		parent=parent, modal=True, message_type=Gtk.MessageType.INFO,
		buttons=Gtk.ButtonsType.OK, text=message)
	dialog.set_border_width(20)
	dialog.connect("response", lambda d, r: d.destroy())
	dialog.connect("delete-event", lambda d, e: d.destroy() or False)
	dialog.show_all()
	dialog.run()
	dialog.destroy()

def open_ssh_in_terminal(terminal, ssh_target, label):
	"""Launch SSH connection in the specified terminal emulator."""
	try:
		# SECURITY: Validate ssh_target format
		if not re.match(r'^[a-zA-Z0-9\-._@:]+$', ssh_target):
			show_notification(f"Invalid SSH target format: {ssh_target}")
			return

		# SECURITY: Quote ssh_target to prevent injection
		ssh_target_safe = shlex.quote(ssh_target)
		
		# Clean up label by trimming quotes and then safely quote it
		label_clean = label.strip('\'"')
		label_safe = shlex.quote(label_clean)

		# Resolve terminal executable path
		terminal_exec = terminal
		if os.path.isabs(terminal) and os.access(terminal, os.X_OK):
			pass
		else:
			terminal_exec = shutil.which(terminal) or terminal

		# Build command based on terminal type (with escape sequences for persistent titles)
		if 'mate-terminal' in terminal_exec:
			cmd = [
				terminal_exec, '--tab', '--title', label_safe, '--',
				'bash', '-c', f'echo -ne "\\033]0;{label_clean}\\007"; ssh {ssh_target_safe}; exec bash'
			]
		elif 'xfce4-terminal' in terminal_exec:
			# Split the command construction to avoid complex escaping
			echo_cmd = f'echo -ne "\\033]0;{label_clean}\\007"'
			ssh_cmd = f'ssh {ssh_target_safe}'
			full_cmd = f'{echo_cmd}; {ssh_cmd}'
			cmd = [
				terminal_exec, '--tab', '--title', label_safe, '--command',
				f'bash -c "{full_cmd}"'
			]
		elif 'gnome-terminal' in terminal_exec:
			cmd = [
				terminal_exec, '--tab', '--title', label_safe, '--',
				'bash', '-c', f'echo -ne "\\033]0;{label_clean}\\007"; ssh {ssh_target_safe}; exec bash'
			]
		elif 'tilix' in terminal_exec:
			cmd = [
				terminal_exec, '--action=session-add-down', '--',
				'bash', '-c', f'echo -ne "\\033]0;{label_clean}\\007"; ssh {ssh_target_safe}; exec bash'
			]
		elif 'konsole' in terminal_exec:
			cmd = [
				terminal_exec, '--new-tab', '-p', f'tabtitle={label_clean}', '-e',
				'bash', '-c', f'echo -ne "\\033]0;{label_clean}\\007"; ssh {ssh_target_safe}; exec bash'
			]
		elif 'xterm' in terminal_exec:
			cmd = [
				terminal_exec, '-T', label_safe, '-e',
				'bash', '-c', f'echo -ne "\\033]0;{label_clean}\\007"; ssh {ssh_target_safe}; exec bash'
			]
		else:
			cmd = [
				terminal_exec, '-e',
				'bash', '-c', f'echo -ne "\\033]0;{label_clean}\\007"; ssh {ssh_target_safe}; exec bash'
			]

		# Launch terminal with enhanced error handling
		process = subprocess.Popen(cmd, stderr=subprocess.PIPE)
		# Check if process failed to start
		if process.poll() is not None and process.returncode != 0:
			show_notification(f"Terminal failed to start: {terminal_exec}")
	except (FileNotFoundError, PermissionError) as e:
		show_notification(f"Cannot launch terminal '{terminal_exec}': {e}")
	except Exception as e:
		show_notification(f"Failed to launch terminal: {e}")

DESKTOP_FILE = os.path.expanduser('~/.local/share/applications/ssh_tray.desktop')
AUTOSTART_DIR = os.path.expanduser('~/.config/autostart')
AUTOSTART_FILE = os.path.join(AUTOSTART_DIR, 'ssh_tray.desktop')

def create_desktop_file(exec_path):
	"""Create .desktop file for application menu integration.
	
	Args:
		exec_path (str): Path to the executable to launch
	"""
	contents = f"""[Desktop Entry]
Type=Application
Name=SSH Bookmark Manager
Exec={exec_path}
Icon={ICON_NAME}
Terminal=false
Categories=Utility;Network;
Comment=SSH tray bookmarks and launcher
"""
	
	# Ensure directory exists and write desktop file
	os.makedirs(os.path.dirname(DESKTOP_FILE), exist_ok=True)
	with open(DESKTOP_FILE, 'w') as f:
		f.write(contents)
	os.chmod(DESKTOP_FILE, 0o755)

def add_to_autostart(enable=True):
	"""Enable or disable application autostart on login.
	
	Args:
		enable (bool): True to enable autostart, False to disable
	"""
	if enable:
		# Copy desktop file to autostart directory
		os.makedirs(AUTOSTART_DIR, exist_ok=True)
		shutil.copy(DESKTOP_FILE, AUTOSTART_FILE)
	else:
		# Remove autostart file if it exists
		if os.path.exists(AUTOSTART_FILE):
			os.remove(AUTOSTART_FILE)

def is_autostart_enabled():
	"""Check if application autostart is currently enabled.
	
	Returns:
		bool: True if autostart file exists, False otherwise
	"""
	return os.path.exists(AUTOSTART_FILE)
</file>

<file path="MAKE.md">
# Developer Guide

**For developers who want to contribute or package SSH Bookmark Manager**

---

## 🏗️ Project Structure

```
ssh-tray/
├── src/ssh_tray/              # Main Python package
│   ├── main.py                # Tray app & menu
│   ├── editor.py              # Bookmark editor dialog
│   ├── sync.py                # Cross-computer sync
│   ├── dialogs.py             # Add/edit dialogs
│   ├── widgets.py             # UI components
│   ├── configuration.py       # Config file handling
│   └── system.py              # Terminal & desktop integration
├── scripts/                   # Build & install scripts
├── config/                    # Sample configs
└── web/                       # Project website
```

---

## 🚀 Quick Development

**Run from source:**
```bash
git clone https://github.com/vordan/ssh-tray.git
cd ssh-tray
python3 src/ssh_tray.py
```

**Install dependencies:**
```bash
sudo apt install python3-gi gir1.2-appindicator3-0.1
```

---

## 🔧 Build Tools

**Create project structure:**
```bash
./scripts/make_ssh_tray_project.sh
```

**Git workflow:**
```bash
./scripts/git_commit.sh "Your commit message"
./scripts/git_init.sh  # Reset repo (destructive!)
```

**Install GitHub CLI:**
```bash
./scripts/github_cli_install.sh
```

---

## 📦 Installation System

- **Location:** `/opt/ssh-tray/` (Linux FHS compliant)
- **Command:** `/usr/local/bin/ssh-tray` (symlink)
- **Uninstaller:** `/usr/local/bin/ssh-tray-uninstall`
- **User config:** `~/.ssh-bookmarks`, `~/.ssh-tray-config`

---

## 🌐 Sync Server (Node.js)

**Deploy your sync service:**
```javascript
// sync-service.js
const http = require('http');
// ... (see full source in repo)
server.listen(9182);
```

**Run:** `node sync-service.js`

**Endpoints:**
- `POST /upload` - Upload config (returns sync ID)
- `GET /download/{syncId}` - Download config
- `GET /status` - Health check

---

## 🧪 Testing

**Manual checklist:**
- [ ] Tray icon appears
- [ ] Bookmarks load/save
- [ ] SSH connections work
- [ ] Editor functions work
- [ ] Sync upload/download
- [ ] Install/uninstall

**Test commands:**
```bash
python3 -m py_compile src/ssh_tray/*.py  # Check syntax
python3 src/ssh_tray.py --help           # Test CLI
python3 src/ssh_tray.py --version        # Test version
```

---

## 🎨 Code Standards

- **Indentation:** Tabs (project standard)
- **Naming:** snake_case functions, CamelCase classes
- **Imports:** Relative imports within package
- **Comments:** Explain what, not what changed
- **Max lines:** 220-250 per file

---

## 🚀 Release Process

1. **Update version** in `src/ssh_tray/__init__.py`
2. **Test thoroughly** (install/uninstall/features)  
3. **Commit changes:** `./scripts/git_commit.sh "v1.x.x"`
4. **Tag release:** `git tag v1.x.x && git push --tags`
5. **Users auto-update** via install script

---

## 📁 File Architecture

**Core modules:**
- `main.py` - GTK tray app, signal handling
- `editor.py` - Main dialog coordinator  
- `sync.py` - Network sync functionality
- `dialogs.py` - Add/edit bookmark dialogs
- `widgets.py` - Reusable UI components
- `configuration.py` - File I/O, validation
- `system.py` - Terminal launch, desktop files

**Design:** Modular, testable, maintainable

---

## 🐛 Common Issues

**Import errors:** Run from project root with `python3 src/ssh_tray.py`
**GTK errors:** Install dev packages: `sudo apt install python3-gi-dev`
**Sync issues:** Check network, server running on port 9182

---

## 🤝 Contributing

1. **Fork** on GitHub
2. **Create branch:** `git checkout -b feature-name`
3. **Follow code standards** above
4. **Test thoroughly**
5. **Submit PR** with clear description

---

## 📞 Contact

**Maintainer:** Vanco Ordanoski  
**Email:** vordan@infoproject.biz  
**Company:** Infoproject LLC, North Macedonia

---

**Development time: ~2-3 hours for new features • Well-documented modular codebase**
</file>

<file path="ssh-tray-start.sh">
#!/bin/bash
# SSH Bookmark Manager startup script
# This script is typically installed to /opt/ssh-tray/ and symlinked from /usr/local/bin/ssh-tray

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Change to the installation directory
cd "$SCRIPT_DIR"

# Launch the SSH Bookmark Manager with proper Python path
exec python3 src/ssh_tray.py "$@"
</file>

<file path="scripts/git_commit.sh">
#!/bin/bash
# git_commit.sh - Commit and push changes to SSH Bookmark Manager repository
# Usage: ./scripts/git_commit.sh "Your commit message"

set -e

# --- Settings ---
GITHUB_USER="vordan"
REPO_NAME="ssh-tray"
# ---------------

# Function: yes/no confirmation prompt with custom default
function confirm() {
	local prompt="$1"
	local default="$2"  # "Y" or "N"
	
	if [[ "$default" == "N" ]]; then
		prompt="$prompt [y/N]"
	else
		prompt="$prompt [Y/n]"
	fi
	
	while true; do
		read -r -p "$prompt " answer
		case "$answer" in
			[Yy][Ee][Ss]|[Yy]) return 0 ;;
			[Nn][Oo]|[Nn]) return 1 ;;
			"") 
				if [[ "$default" == "N" ]]; then
					return 1  # Default No
				else
					return 0  # Default Yes
				fi
				;;
			*) echo "Please answer y or n." ;;
		esac
	done
}

# Check for commit message or prompt for one
if [[ -z "$1" ]]; then
	echo "No commit message provided."
	echo
	read -r -p "Enter commit message: " COMMIT_MSG
	
	# Check if user provided a message
	if [[ -z "$COMMIT_MSG" ]]; then
		echo "Error: Commit message cannot be empty."
		echo
		echo "Usage: $0 \"commit message\""
		echo
		echo "Examples:"
		echo "  $0 \"Fix terminal detection bug\""
		echo "  $0 \"Add support for new terminal emulator\""
		echo "  $0 \"Update documentation and README\""
		exit 1
	fi
else
	COMMIT_MSG="$1"
fi

echo "==============================================================================="
echo "SSH Bookmark Manager - Git Commit & Push"
echo "==============================================================================="
echo

# Auto-detect project root directory and change to it
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ "$(basename "$SCRIPT_DIR")" == "scripts" ]]; then
	# Running from scripts/ directory, go up one level
	PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
	echo "Detected running from scripts/ directory, changing to project root..."
	cd "$PROJECT_ROOT"
fi

# Check if we're in a git repository
if [[ ! -d ".git" ]]; then
	echo "ERROR: Not in a git repository."
	echo "Current directory: $(pwd)"
	echo "If this is a new project, run ./scripts/git_init.sh first."
	exit 1
fi

# Verify we're in the right project (should have src/ and scripts/)
if [[ ! -d "src" || ! -d "scripts" ]]; then
	echo "ERROR: Cannot find SSH Bookmark Manager project structure."
	echo "Expected to find src/ and scripts/ directories."
	echo "Current directory: $(pwd)"
	exit 1
fi

echo "Working in project directory: $(pwd)"

# Check if we have the correct remote
REMOTE_URL=$(git remote get-url origin 2>/dev/null || echo "")
EXPECTED_URL="https://github.com/$GITHUB_USER/$REPO_NAME.git"

if [[ "$REMOTE_URL" != "$EXPECTED_URL" ]]; then
	echo "WARNING: Remote origin URL doesn't match expected repository."
	echo "Current: $REMOTE_URL"
	echo "Expected: $EXPECTED_URL"
	echo
	if ! confirm "Continue anyway?" "N"; then
		echo "Aborted by user."
		exit 1
	fi
fi

# Show git status
echo "Current repository status:"
MODIFIED_COUNT=$(git status --porcelain | wc -l)
NEW_FILES=$(git status --porcelain | grep "^??" | wc -l)
STAGED_COUNT=$(git status --porcelain | grep "^[AMDR]" | wc -l)

echo "  Modified/Deleted: $(($MODIFIED_COUNT - $NEW_FILES))"
echo "  New files: $NEW_FILES"
echo "  Already staged: $STAGED_COUNT"
echo

# Show changes summary
if [[ $MODIFIED_COUNT -eq 0 ]]; then
	echo "No changes to commit."
	exit 0
fi

echo "Files that will be added/committed:"
git status --short
echo

# Confirm commit
echo "Commit message: \"$COMMIT_MSG\""
echo
if ! confirm "Review changes and continue with commit and push?" "Y"; then
	echo "Aborted by user."
	exit 1
fi

# Optional: Show detailed diff (default: No)
echo
if confirm "Show detailed diff before committing?" "N"; then
	echo
	echo "==============================================================================="
	echo "DIFF PREVIEW:"
	echo "==============================================================================="
	git diff HEAD 2>/dev/null || git diff --cached 2>/dev/null || git diff
	echo "==============================================================================="
	echo
	if ! confirm "Proceed with commit after reviewing diff?" "Y"; then
		echo "Aborted by user."
		exit 1
	fi
fi

echo "Adding all changes (including new files and folders)..."
git add .

# Show what will be committed
echo "Files to be committed:"
git diff --cached --name-status

echo "Committing changes..."
git commit -m "$COMMIT_MSG"

echo "Pushing to GitHub..."
git push

echo
echo "==============================================================================="
echo "✓ SUCCESS: Changes committed and pushed to GitHub!"
echo "==============================================================================="
echo
echo "Commit: $COMMIT_MSG"
echo "Repository: https://github.com/$GITHUB_USER/$REPO_NAME"
echo
echo "View changes:"
echo "  - On GitHub: https://github.com/$GITHUB_USER/$REPO_NAME/commits"
echo "  - Locally: git log --oneline -10"
echo
</file>

<file path="scripts/uninstall.sh">
#!/bin/bash
# uninstall.sh - SSH Bookmark Manager Uninstaller
# Safely removes the application and optionally backs up user configuration

set -e

# --- Settings ---
INSTALL_DIR="/opt/ssh-tray"
BIN_SYMLINK="/usr/local/bin/ssh-tray"
BOOKMARKS_FILE="$HOME/.ssh_bookmarks"
CONFIG_FILE="$HOME/.ssh_tray_config"
DESKTOP_FILE="$HOME/.local/share/applications/ssh_tray.desktop"
AUTOSTART_FILE="$HOME/.config/autostart/ssh_tray.desktop"
BACKUP_DIR="$HOME/Downloads/ssh-tray-backup-$(date +%Y%m%d-%H%M%S)"
# ---------------

echo "==============================================================================="
echo "SSH Bookmark Manager - Uninstaller"
echo "==============================================================================="
echo
echo "This script will remove SSH Bookmark Manager from your system."
echo
echo "Files that will be removed:"
echo "  • Application: $INSTALL_DIR"
echo "  • Symlink: $BIN_SYMLINK"
echo "  • Desktop file: $DESKTOP_FILE"
echo "  • Autostart file: $AUTOSTART_FILE"
echo
echo "Configuration files (if they exist):"
echo "  • Bookmarks: $BOOKMARKS_FILE"
echo "  • Config: $CONFIG_FILE"
echo

# Function: yes/no confirmation prompt
function confirm() {
	while true; do
		read -r -p "$1 [Y/n] " answer
		case "$answer" in
			[Yy][Ee][Ss]|[Yy]|"") return 0 ;;
			[Nn][Oo]|[Nn]) return 1 ;;
			*) echo "Please answer Y or n." ;;
		esac
	done
}

# Function: Check if file exists and is not empty
function file_exists_and_not_empty() {
	[[ -f "$1" && -s "$1" ]]
}

# Function: Stop the application if running
function stop_application() {
	echo "Checking if SSH Bookmark Manager is running..."

	# Find and kill any running instances
	PIDS=$(pgrep -f "ssh_tray" 2>/dev/null || true)
	if [[ -n "$PIDS" ]]; then
		echo "Found running SSH Bookmark Manager processes: $PIDS"
		if confirm "Stop running SSH Bookmark Manager processes?"; then
			echo "Stopping SSH Bookmark Manager..."
			pkill -f "ssh_tray" -u "$(id -u)" 2>/dev/null || true
			sleep 2

			# Force kill if still running
			PIDS=$(pgrep -f "ssh_tray" 2>/dev/null || true)
			if [[ -n "$PIDS" ]]; then
				echo "Force stopping remaining processes..."
				pkill -9 -f "ssh_tray" -u "$(id -u)" 2>/dev/null || true
			fi
			echo "✓ SSH Bookmark Manager stopped"
		else
			echo "WARNING: Application is still running. Uninstall may not be complete."
		fi
	else
		echo "✓ No running processes found"
	fi
}

# Function: Backup configuration files
function backup_config_files() {
	local backup_needed=false

	# Check if any config files exist and are not empty
	if file_exists_and_not_empty "$BOOKMARKS_FILE"; then
		echo "✓ Found bookmarks file with content: $BOOKMARKS_FILE"
		backup_needed=true
	fi

	if file_exists_and_not_empty "$CONFIG_FILE"; then
		echo "✓ Found config file with content: $CONFIG_FILE"
		backup_needed=true
	fi

	if [[ "$backup_needed" == "true" ]]; then
		echo
		echo "You have SSH bookmarks and/or configuration files that will be deleted."
		if confirm "Create backup of your configuration files before deletion?"; then
			echo "Creating backup directory: $BACKUP_DIR"
			mkdir -p "$BACKUP_DIR"

			if file_exists_and_not_empty "$BOOKMARKS_FILE"; then
				cp "$BOOKMARKS_FILE" "$BACKUP_DIR/"
				echo "✓ Backed up: $(basename "$BOOKMARKS_FILE")"
			fi

			if file_exists_and_not_empty "$CONFIG_FILE"; then
				cp "$CONFIG_FILE" "$BACKUP_DIR/"
				echo "✓ Backed up: $(basename "$CONFIG_FILE")"
			fi

			echo "✓ Configuration backup created in: $BACKUP_DIR"
			echo
		fi
	else
		echo "ℹ No configuration files found or they are empty"
	fi
}

# Function: Remove application files
function remove_application() {
	echo "Removing application files..."

	# Remove symlink
	if [[ -L "$BIN_SYMLINK" ]]; then
		echo "Removing symlink: $BIN_SYMLINK"
		sudo rm -f "$BIN_SYMLINK"
		echo "✓ Symlink removed"
	elif [[ -f "$BIN_SYMLINK" ]]; then
		echo "Removing file: $BIN_SYMLINK"
		sudo rm -f "$BIN_SYMLINK"
		echo "✓ Binary removed"
	else
		echo "ℹ Symlink not found: $BIN_SYMLINK"
	fi

	# Remove installation directory
	if [[ -d "$INSTALL_DIR" ]]; then
		echo "Removing installation directory: $INSTALL_DIR"
		sudo rm -rf "$INSTALL_DIR"
		echo "✓ Installation directory removed"
	else
		echo "ℹ Installation directory not found: $INSTALL_DIR"
	fi
}

# Function: Remove user files
function remove_user_files() {
	echo "Removing user configuration and desktop files..."

	# Remove desktop file
	if [[ -f "$DESKTOP_FILE" ]]; then
		rm -f "$DESKTOP_FILE"
		echo "✓ Desktop file removed: $DESKTOP_FILE"
	else
		echo "ℹ Desktop file not found"
	fi

	# Remove autostart file
	if [[ -f "$AUTOSTART_FILE" ]]; then
		rm -f "$AUTOSTART_FILE"
		echo "✓ Autostart file removed: $AUTOSTART_FILE"
	else
		echo "ℹ Autostart file not found"
	fi

	# Remove config files
	if [[ -f "$BOOKMARKS_FILE" ]]; then
		rm -f "$BOOKMARKS_FILE"
		echo "✓ Bookmarks file removed: $BOOKMARKS_FILE"
	else
		echo "ℹ Bookmarks file not found"
	fi

	if [[ -f "$CONFIG_FILE" ]]; then
		rm -f "$CONFIG_FILE"
		echo "✓ Config file removed: $CONFIG_FILE"
	else
		echo "ℹ Config file not found"
	fi
}

# Main uninstall process
echo "Starting uninstall process..."
echo

# Final confirmation
if ! confirm "Are you sure you want to completely remove SSH Bookmark Manager?"; then
	echo "Uninstall cancelled by user."
	exit 0
fi

echo

# Stop the application
stop_application
echo

# Backup configuration files
backup_config_files

# Remove application files (requires sudo)
echo "Application removal requires sudo privileges..."
if ! sudo -v; then
	echo "ERROR: sudo access required to remove application from $INSTALL_DIR"
	exit 1
fi
echo

remove_application
echo

# Remove user files
if confirm "Remove your personal configuration files and desktop integration?"; then
	remove_user_files
else
	echo "Keeping personal configuration files:"
	[[ -f "$BOOKMARKS_FILE" ]] && echo "  • $BOOKMARKS_FILE"
	[[ -f "$CONFIG_FILE" ]] && echo "  • $CONFIG_FILE"
	[[ -f "$DESKTOP_FILE" ]] && echo "  • $DESKTOP_FILE"
	[[ -f "$AUTOSTART_FILE" ]] && echo "  • $AUTOSTART_FILE"
fi

echo
echo "==============================================================================="
echo "✓ SSH Bookmark Manager uninstall completed!"
echo "==============================================================================="
echo

# Show backup location if created
if [[ -d "$BACKUP_DIR" ]]; then
	echo "Your configuration backup is saved at:"
	echo "  $BACKUP_DIR"
	echo
	echo "Backup contains:"
	ls -la "$BACKUP_DIR"
	echo
fi

echo "What was removed:"
echo "  • Application directory: $INSTALL_DIR"
echo "  • Command symlink: $BIN_SYMLINK"
echo "  • Desktop integration files"
echo "  • Configuration files (if selected)"
echo
echo "To reinstall SSH Bookmark Manager, run the installer script again."
echo "Your backed up configuration can be restored by copying the files back to:"
echo "  • $BOOKMARKS_FILE"
echo "  • $CONFIG_FILE"
echo
</file>

<file path="src/ssh_tray.py">
#!/usr/bin/env python3
"""
SSH Bookmark Manager - Main Launcher Script
============================================

This is the main entry point for the SSH Bookmark Manager application.
It imports and runs the main application from the ssh_tray package.

Author: Vanco Ordanoski
Company: Infoproject LLC, North Macedonia
License: MIT
"""

import sys
import os
import subprocess

def show_help():
	"""Display help information and available commands."""
	print("SSH Bookmark Manager")
	print("===================")
	print()
	print("Usage:")
	print("  ssh-tray                 Start the tray application")
	print("  ssh-tray --help          Show this help message")
	print("  ssh-tray --version       Show version information")
	print("  ssh-tray --uninstall     Uninstall SSH Bookmark Manager")
	print()
	print("Configuration files:")
	print("  ~/.ssh_bookmarks         Your SSH bookmarks")
	print("  ~/.ssh_tray_config       Terminal and application settings")
	print()
	print("For more information, see the tray menu when the application is running.")

def show_version():
	"""Display version information."""
	try:
		# Add the parent directory to Python path to find the ssh_tray package
		sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
		from ssh_tray import __version__, __author__, __company__

		print(f"SSH Bookmark Manager v{__version__}")
		print(f"Author: {__author__}")
		print(f"Company: {__company__}")
		print("License: MIT")
	except ImportError:
		print("SSH Bookmark Manager")
		print("Version information unavailable")

def run_uninstaller():
	"""Run the uninstaller script."""
	# Find the uninstaller script
	script_dir = os.path.dirname(os.path.abspath(__file__))

	# Try different possible locations for the uninstaller
	possible_paths = [
		os.path.join(script_dir, 'uninstall.sh'),
		os.path.join(script_dir, 'scripts', 'uninstall.sh'),
		'/usr/local/bin/ssh-tray-uninstall',
		'/opt/ssh-tray/uninstall.sh'
	]

	uninstaller_path = None
	for path in possible_paths:
		if os.path.exists(path) and os.access(path, os.X_OK):
			uninstaller_path = path
			break

	if uninstaller_path:
		print("Starting SSH Bookmark Manager uninstaller...")
		try:
			# Execute the uninstaller script
			subprocess.run([uninstaller_path], check=True)
		except subprocess.CalledProcessError as e:
			print(f"Uninstaller exited with error code {e.returncode}")
			sys.exit(e.returncode)
		except KeyboardInterrupt:
			print("\nUninstall cancelled by user.")
			sys.exit(1)
	else:
		print("ERROR: Uninstaller script not found.")
		print("Please run the uninstaller manually:")
		print("  /opt/ssh-tray/uninstall.sh")
		print("  or")
		print("  ssh-tray-uninstall")
		sys.exit(1)

def main():
	"""Main launcher function that handles command-line arguments."""
	# Check for command-line arguments
	if len(sys.argv) > 1:
		arg = sys.argv[1].lower()

		if arg in ['--help', '-h', 'help']:
			show_help()
			return
		elif arg in ['--version', '-v', 'version']:
			show_version()
			return
		elif arg in ['--uninstall', 'uninstall']:
			run_uninstaller()
			return
		else:
			print(f"Unknown argument: {sys.argv[1]}")
			print("Use 'ssh-tray --help' for available options.")
			sys.exit(1)

	# No arguments provided, start the main application
	# Add the parent directory to Python path to find the ssh_tray package
	sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

	try:
		# Import and run the main application
		import ssh_tray.main
		app_main = ssh_tray.main.main
		app_main()

	except ImportError as e:
		print(f"Error importing SSH Tray modules: {e}")
		print("Please ensure the ssh_tray package is properly installed.")
		sys.exit(1)
	except Exception as e:
		print(f"Error starting SSH Bookmark Manager: {e}")
		sys.exit(1)

if __name__ == '__main__':
	main()
</file>

<file path="README.md">
# SSH Bookmark Manager

**One-click SSH access from your system tray** • *Linux desktop app for managing SSH connections*

![Version](https://img.shields.io/badge/version-1.0.0-blue) ![License](https://img.shields.io/badge/license-MIT-green)

![SSH Tray Menu](docs/images/main-menu.png)
*Right-click the tray icon to see all your servers organized by groups - click any bookmark to connect instantly*

---

## ⚡ Quick Start

**Install:**
```bash
curl -fsSL https://raw.githubusercontent.com/vordan/ssh-tray/main/install.sh | bash
```

**Run:**
```bash
ssh-tray
```

**Use:** Right-click tray icon → Add your servers → Click to connect!

![System Tray Icon](docs/images/tray-icon.png)
*SSH Bookmark Manager sits quietly in your system tray, ready when you need it*

---

## ✨ Features

- 🖱️ **One-click SSH** from system tray
- 📁 **Group bookmarks** by project/environment  
- 🖥️ **Works with any terminal** (mate, gnome, xfce4, etc.)
- 🔄 **Sync across computers** with your private server
- ⚙️ **Autostart** and desktop integration
- 📝 **Simple text config** files

![Bookmark Editor](docs/images/editor-dialog.png)
*Powerful yet simple editor for managing bookmarks, groups, terminal settings, and sync options*

---

## 📋 Requirements

- **Linux** with system tray (Ubuntu, Mint, Fedora, etc.)
- **Python 3.6+** with GTK3 bindings
- **Terminal emulator** (usually pre-installed)

**Install dependencies:**
```bash
# Ubuntu/Debian
sudo apt install python3-gi gir1.2-appindicator3-0.1

# Fedora  
sudo dnf install python3-gobject libappindicator-gtk3-devel
```

---

## 🚀 Usage

### Basic Setup
1. **Start SSH Tray:** `ssh-tray`
2. **Right-click tray icon** → "Edit bookmarks/config"
3. **Add your servers** with the GUI editor
4. **Click any bookmark** to connect instantly

![Terminal Connection](docs/images/terminal-ssh.png)
*SSH connections open in new tabs of your preferred terminal with custom titles*

### Bookmark Format
Edit `~/.ssh-bookmarks` directly if you prefer:
```
------ Development ------
Web Server	user@dev.example.com
Database	admin@db.dev.example.com:2222

------ Production ------  
App Server	deploy@prod.example.com
```

### Sync Across Computers
1. **Enable sync** in settings
2. **Upload bookmarks** → get sync ID
3. **On other computer:** Download with sync ID
4. **Done!** Bookmarks synced instantly

![Sync Settings](docs/images/sync-settings.png)
*Configure your private sync server and share bookmark configurations across multiple computers*

---

## ⚙️ Configuration

**Terminal:** Edit `~/.ssh-tray-config`
```
terminal=mate-terminal
sync_enabled=true
sync_server=your-server.com
sync_port=9182
```

**Supported terminals:** mate-terminal, gnome-terminal, xfce4-terminal, tilix, konsole, lxterminal, xterm

---

## 🔧 Commands

```bash
ssh-tray                # Start application
ssh-tray --help         # Show help
ssh-tray --version      # Show version  
ssh-tray --uninstall    # Remove application
```

---

## 🗑️ Uninstall

```bash
ssh-tray --uninstall
```
*Offers to backup your bookmarks before removal*

---

## 🛠️ Development

**Run from source:**
```bash
git clone https://github.com/vordan/ssh-tray.git
cd ssh-tray
python3 src/ssh_tray.py
```

**Project structure:**
```
src/ssh_tray/          # Main Python package
├── main.py            # Tray application
├── editor.py          # Bookmark editor
├── sync.py            # Cross-computer sync
└── ...
```

---

## 📞 Support

- **Issues:** [GitHub Issues](https://github.com/vordan/ssh-tray/issues)
- **Email:** vordan@infoproject.biz
- **Company:** Infoproject LLC, North Macedonia

---

## 📄 License

MIT License - see [LICENSE.md](LICENSE.md)

---

**Made with ❤️ for Linux desktop users who love SSH**
</file>

</files>
